<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Kotlin lang 学习笔记 | emacsist</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="java,kotlin," />
  

  <meta name="description" content="基本语法定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置  源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等  特别地, 如果没指定包, 则该文件属于 default 包.(没有显式的名称的包)  默认导入的包所有 kotlin 文件默认情况下, 都会导入以下包 12345678kotlin.*kotlin.annotation.*kotlin">
<meta name="keywords" content="java,kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin lang 学习笔记">
<meta property="og:url" content="https://emacsist.github.io/2018/03/01/Kotlin-lang-学习笔记/index.html">
<meta property="og:site_name" content="emacsist">
<meta property="og:description" content="基本语法定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置  源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等  特别地, 如果没指定包, 则该文件属于 default 包.(没有显式的名称的包)  默认导入的包所有 kotlin 文件默认情况下, 都会导入以下包 12345678kotlin.*kotlin.annotation.*kotlin">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-05T04:22:24.124Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin lang 学习笔记">
<meta name="twitter:description" content="基本语法定义 package 不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置  源文件中的所有内容, 都是通过包声明来包含的. 即: 名包.方法名 等  特别地, 如果没指定包, 则该文件属于 default 包.(没有显式的名称的包)  默认导入的包所有 kotlin 文件默认情况下, 都会导入以下包 12345678kotlin.*kotlin.annotation.*kotlin">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b870e52c6cd914cb42627e4a706700b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  

  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/books/"
            rel="noopener noreferrer"
            target="_self"
            >
            阅读
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本语法"><span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-package"><span class="toc-text">定义 package</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认导入的包"><span class="toc-text">默认导入的包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import-导入包"><span class="toc-text">import, 导入包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义函数"><span class="toc-text">定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参数定义"><span class="toc-text">参数定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认参数"><span class="toc-text">默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#override-method"><span class="toc-text">override method</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名参数"><span class="toc-text">命名参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#命名参数与位置参数混合调用时"><span class="toc-text">命名参数与位置参数混合调用时</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变参数"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unit-返回类型"><span class="toc-text">Unit 返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单一表达式-函数-Single-Expression-function"><span class="toc-text">单一表达式 函数 (Single-Expression function)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#infix-符号"><span class="toc-text">infix 符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数作用域"><span class="toc-text">函数作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#local-function"><span class="toc-text">local function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#member-function"><span class="toc-text">member function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#generic-function"><span class="toc-text">generic function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inline-function"><span class="toc-text">inline function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extension-function"><span class="toc-text">extension function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#higher-order-function-和-lambda"><span class="toc-text">higher-order function 和 lambda</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tail-recursive-function"><span class="toc-text">tail recursive function</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义变量"><span class="toc-text">定义变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义属性"><span class="toc-text">定义属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#compile-time-constant"><span class="toc-text">compile time constant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#late-initialized-属性和变量-延迟初始化"><span class="toc-text">late initialized 属性和变量(延迟初始化)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注释"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用字符串模板"><span class="toc-text">使用字符串模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-安全的"><span class="toc-text">Null 安全的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用"><span class="toc-text">调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检查-null-条件"><span class="toc-text">检查 null 条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全调用"><span class="toc-text">安全调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elvis-操作符"><span class="toc-text">elvis 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符"><span class="toc-text">!! 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全转换"><span class="toc-text">安全转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullable-类型的集合"><span class="toc-text">nullable 类型的集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用类型检查和自动转换"><span class="toc-text">使用类型检查和自动转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-for-循环"><span class="toc-text">使用 for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-while-循环"><span class="toc-text">使用 while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when-表达式"><span class="toc-text">when 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-range"><span class="toc-text">使用 range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用集合"><span class="toc-text">使用集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建基本类和它们的实例"><span class="toc-text">创建基本类和它们的实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码组织"><span class="toc-text">源码组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录结构"><span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码文件名"><span class="toc-text">源码文件名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源文件的组织"><span class="toc-text">源文件的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类层次"><span class="toc-text">类层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口实现层"><span class="toc-text">接口实现层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载层"><span class="toc-text">重载层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命名规则"><span class="toc-text">命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数名"><span class="toc-text">函数名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试方法的命名"><span class="toc-text">测试方法的命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性名"><span class="toc-text">属性名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#修饰符的顺序"><span class="toc-text">修饰符的顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lable"><span class="toc-text">Lable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#return-中使用-label"><span class="toc-text">return 中使用 label</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class-和-继承"><span class="toc-text">class 和 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主构造器"><span class="toc-text">主构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#次构造器"><span class="toc-text">次构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化块"><span class="toc-text">初始化块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建实例"><span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-成员"><span class="toc-text">class 成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写方法"><span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写属性"><span class="toc-text">重写属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类初始化顺序"><span class="toc-text">子类初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用父类的实现"><span class="toc-text">调用父类的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重写规则"><span class="toc-text">重写规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-class"><span class="toc-text">abstract class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Companion-Objects"><span class="toc-text">Companion Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Declaration"><span class="toc-text">Object Declaration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#companion-object"><span class="toc-text">companion object</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#属性和字段"><span class="toc-text">属性和字段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明属性"><span class="toc-text">声明属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setter-和-getter"><span class="toc-text">setter 和 getter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口-interface"><span class="toc-text">接口 interface</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口中的属性"><span class="toc-text">接口中的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写时的冲突解决"><span class="toc-text">重写时的冲突解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问修饰符"><span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#module"><span class="toc-text">module</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#extension-扩展"><span class="toc-text">extension 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#extension-function-1"><span class="toc-text">extension function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extension-是静态解析的"><span class="toc-text">extension 是静态解析的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nullable-接收者"><span class="toc-text">nullable 接收者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extension-属性"><span class="toc-text">extension 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Companion-Object-Extensions"><span class="toc-text">Companion Object Extensions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-extension-作为成员"><span class="toc-text">定义 extension 作为成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-classes"><span class="toc-text">Data classes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在-body-里声明属性"><span class="toc-text">在 body 里声明属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copying"><span class="toc-text">copying</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sealed-Classes"><span class="toc-text">Sealed Classes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#generic-泛型"><span class="toc-text">generic 泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌套类和内部类"><span class="toc-text">嵌套类和内部类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举类"><span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#object-expression-和-declaration"><span class="toc-text">object expression 和 declaration</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegation-委托"><span class="toc-text">Delegation 委托</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegated-Properties"><span class="toc-text">Delegated Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#标准的-delegates"><span class="toc-text">标准的 delegates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storing-Properties-in-a-Map"><span class="toc-text">Storing Properties in a Map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#higher-order-function-和-lambda-1"><span class="toc-text">higher-order function 和 lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#it-隐式的单一的参数名字"><span class="toc-text">it : 隐式的单一的参数名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略参数-1-1-版本开始"><span class="toc-text">_ : 忽略参数:(1.1 版本开始)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-function-1"><span class="toc-text">inline function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-expression-和-匿名函数"><span class="toc-text">lambda expression 和 匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名函数"><span class="toc-text">匿名函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#closures"><span class="toc-text">closures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function-literal-与-receiver"><span class="toc-text">function literal 与 receiver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#inline-function-2"><span class="toc-text">inline function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#开启-inline"><span class="toc-text">开启 inline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#noinline"><span class="toc-text">noinline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-properties"><span class="toc-text">inline properties</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#destructuring-declaration"><span class="toc-text">destructuring declaration</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从一个函数中返回2个值"><span class="toc-text">从一个函数中返回2个值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在-map-中使用"><span class="toc-text">在 map 中使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在-lambda-中使用"><span class="toc-text">在 lambda 中使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections"><span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this-expression"><span class="toc-text">this expression</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#equality-相等"><span class="toc-text">equality 相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作符重载"><span class="toc-text">操作符重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#annotation"><span class="toc-text">annotation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Type-aliases-类型别名"><span class="toc-text">Type aliases 类型别名</span></a></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-Kotlin-lang-学习笔记" class="article article-type-post" itemprop="blogPost">
    <header class="article-header">
        <h1 class="post-title">
            Kotlin lang 学习笔记
        </h1>

        <div class="article-meta">
            <span>
        <i class="icon-calendar"></i>
        <span>2018.03.01</span>
            </span>

            
                <span class="article-author">
          <i class="icon-user"></i>
          <span>emacsist</span>
                </span>
                

                    
    <span class="article-category">
    <i class="icon-list"></i>
    
      <a class="tag-item" href="/tags/#java">
        <span class="tag-name">java</span>
    <span class="tag-size">( 127 )</span>
    </a>
    
      <a class="tag-item" href="/tags/#kotlin">
        <span class="tag-name">kotlin</span>
    <span class="tag-size">( 1 )</span>
    </a>
    

        </span>
        

                        

                                

                                        

        </div>
    </header>

    <div class="article-content">
        
                            <h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="定义-package"><a href="#定义-package" class="headerlink" title="定义 package"></a>定义 package</h2><blockquote>
<p>不要求目录与包相匹配~: 源文件可以放在文件系统的任意位置</p>
</blockquote>
<p>源文件中的所有内容, 都是通过包声明来包含的. 即: <code>名包.方法名</code> 等</p>
<blockquote>
<p>特别地, 如果没指定包, 则该文件属于 <code>default</code> 包.(没有显式的名称的包)</p>
</blockquote>
<h3 id="默认导入的包"><a href="#默认导入的包" class="headerlink" title="默认导入的包"></a>默认导入的包</h3><p>所有 kotlin 文件默认情况下, 都会导入以下包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">kotlin.*</div><div class="line">kotlin.annotation.*</div><div class="line">kotlin.collections.*</div><div class="line">kotlin.comparisons.* (since 1.1)</div><div class="line">kotlin.io.*</div><div class="line">kotlin.ranges.*</div><div class="line">kotlin.sequences.*</div><div class="line">kotlin.text.*</div></pre></td></tr></table></figure>
<p>根据不同的目标平台, 还会导入一些额外的包:</p>
<ul>
<li>JVM 平台</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.*</div><div class="line">kotlin.jvm.*</div></pre></td></tr></table></figure>
<ul>
<li>JS 平台</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kotlin.js.*</div></pre></td></tr></table></figure>
<h2 id="import-导入包"><a href="#import-导入包" class="headerlink" title="import, 导入包"></a>import, 导入包</h2><blockquote>
<p>import 指令不必限制于 classes 的, 你可以用它来导入其他的声明:</p>
</blockquote>
<ul>
<li>顶层的 方法和属性</li>
<li>声明在对象声明里的 方法和属性</li>
<li>枚举常量</li>
</ul>
<blockquote>
<p>不同于Java, Kotlin 没有单独的 <code>import static</code> 语法. 所有的导入, 都是通过 <code>import</code> 来声明的</p>
</blockquote>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import foo.Bar</div><div class="line"></div><div class="line">import foo.*</div><div class="line"></div><div class="line">import bar.Bar as bBar</div></pre></td></tr></table></figure>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>函数是通过 <code>fun</code> 关键字来定义的</p>
<h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><p>它是使用 <code>Pascal</code> 风格来定义的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: <span class="built_in">type</span></div></pre></td></tr></table></figure>
<p>即, <code>名称: 类型</code></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>即在 <code>type</code> 后使用 <code>= defaultValue</code> 来定义. 如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun <span class="built_in">read</span>(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="override-method"><a href="#override-method" class="headerlink" title="override method"></a>override method</h5><p><code>override method</code> 总是与 <code>base method</code> 使用相同的默认值的!(注意, <code>总是</code>, always)~</p>
<p>当 <code>override method</code> 时, 要注意在方法签名里, 不能带有默认值! 否则会报如下错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An overriding <span class="keyword">function</span> is not allowed to specify default values <span class="keyword">for</span> its parameters</div></pre></td></tr></table></figure>
<blockquote>
<p>如果一个方法中, 前面带有默认参数, 后面参数没有时, 这时如果想利用默认参数值的话, 则只能通过命名参数的方式来调用方法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun foo(bar: Int = 0, baz: Int) &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">foo(baz = 1) // The default value bar = 0 is used</div></pre></td></tr></table></figure>
<p>但, 如果最后一个参数是 <code>lambda</code> 时, 则允许只直接传递最后一个没有默认值的 <code>lambda</code> 参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun foo(bar: Int = 0, baz: Int = 1, qux: () -&gt; Unit) &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">foo(1) &#123; println(<span class="string">"hello"</span>) &#125; // Uses the default value baz = 1 </div><div class="line">foo &#123; println(<span class="string">"hello"</span>) &#125;    // Uses both default values bar = 0 and baz = 1</div></pre></td></tr></table></figure>
<h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>当调用方法时, 允许通过命名参数的方式来调用.</p>
<h5 id="命名参数与位置参数混合调用时"><a href="#命名参数与位置参数混合调用时" class="headerlink" title="命名参数与位置参数混合调用时"></a>命名参数与位置参数混合调用时</h5><p>规则为: 所有的位置参数必须在第一个命名参数的前面.即:</p>
<p>允许:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(1, y = 2)</div></pre></td></tr></table></figure>
<p>但不允许:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(x = 1, 2)</div></pre></td></tr></table></figure>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p><code>vararg</code> 来声明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun foo(vararg strings: String) &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">foo(strings = *arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</div></pre></td></tr></table></figure>
<h4 id="Unit-返回类型"><a href="#Unit-返回类型" class="headerlink" title="Unit 返回类型"></a>Unit 返回类型</h4><p>如果一个方法没有返回值, 则它的返回类型为 <code>Unit</code>, 它是一种仅有唯一值 <code>Unit</code> 的类型.(可以忽略显式写法)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun printHello(name: String?): Unit &#123;</div><div class="line">    <span class="keyword">if</span> (name != null)</div><div class="line">        println(<span class="string">"Hello <span class="variable">$&#123;name&#125;</span>"</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        println(<span class="string">"Hi there!"</span>)</div><div class="line">    // `<span class="built_in">return</span> Unit` or `<span class="built_in">return</span>` is optional</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printHello(name: String?) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单一表达式-函数-Single-Expression-function"><a href="#单一表达式-函数-Single-Expression-function" class="headerlink" title="单一表达式 函数 (Single-Expression function)"></a>单一表达式 函数 (Single-Expression function)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun double(x: Int): Int = x * 2</div></pre></td></tr></table></figure>
<h4 id="infix-符号"><a href="#infix-符号" class="headerlink" title="infix 符号"></a>infix 符号</h4><p>通过 <code>infix</code> 关键字的 <code>function</code> 也被称为使用 <code>infix</code> 符号记法(即, 允许忽略点和括号来调用). 它必须满足以下条件:</p>
<ul>
<li>它们必须是成员函数(member function)或扩展函数(extension function)</li>
<li>它们必须有一个参数</li>
<li>参数一定不能为可变参数, 也不能有默认值</li>
</ul>
<p>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">infix fun Int.shl(x: Int): Int &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// calling the <span class="keyword">function</span> using the infix notation</div><div class="line">1 shl 2</div><div class="line"></div><div class="line">// is the same as</div><div class="line">1.shl(2)</div></pre></td></tr></table></figure>
<blockquote>
<p>注意, infix 函数 比 算术操作符, 类型转换换以入 rangeTo 操作符的优先级更低!</p>
</blockquote>
<p>注意, infix 函数总是要求指定 <code>receiver</code> 和 <code>parameter</code> 的!</p>
<ul>
<li>当你在一个方法里调用 infix 函数时, 你需要显式使用 <code>this</code> 作为 <code>receiver</code>, 其他的方法允许忽略它, 但 infix 方法不能忽略 <code>this</code>.</li>
</ul>
<p>这种要求用来确保解释时没有歧义!</p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><h5 id="local-function"><a href="#local-function" class="headerlink" title="local function"></a>local function</h5><p>本地函数. 即一个函数在另一个函数里面.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun dfs(graph: Graph) &#123;</div><div class="line">    fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) &#123;</div><div class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="built_in">return</span></div><div class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</div><div class="line">            dfs(v, visited)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dfs(graph.vertices[0], HashSet())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>local function</code> 可以访问外部函数的 <code>local variable</code>. 如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun dfs(graph: Graph) &#123;</div><div class="line">    val visited = HashSet&lt;Vertex&gt;()</div><div class="line">    fun dfs(current: Vertex) &#123;</div><div class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="built_in">return</span></div><div class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</div><div class="line">            dfs(v)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dfs(graph.vertices[0])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class <span class="function"><span class="title">Sample</span></span>() &#123;</div><div class="line">    fun <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Sample().foo() // creates instance of class Sample and calls foo</div></pre></td></tr></table></figure>
<h5 id="generic-function"><a href="#generic-function" class="headerlink" title="generic function"></a>generic function</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="inline-function"><a href="#inline-function" class="headerlink" title="inline function"></a>inline function</h5><h5 id="extension-function"><a href="#extension-function" class="headerlink" title="extension function"></a>extension function</h5><h5 id="higher-order-function-和-lambda"><a href="#higher-order-function-和-lambda" class="headerlink" title="higher-order function 和 lambda"></a>higher-order function 和 lambda</h5><h5 id="tail-recursive-function"><a href="#tail-recursive-function" class="headerlink" title="tail recursive function"></a>tail recursive function</h5><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int): Int &#123;</div><div class="line">    <span class="built_in">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int) = a + b</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int): Unit &#123;</div><div class="line">    println(<span class="string">"sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="variable">$&#123;a + b&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int) &#123;</div><div class="line">    println(<span class="string">"sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="variable">$&#123;a + b&#125;</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>一次性声明 local variable(read only):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1  // immediate assignment</div><div class="line">val b = 2   // `Int` <span class="built_in">type</span> is inferred</div><div class="line">val c: Int  // Type required when no initializer is provided</div><div class="line">c = 3       // deferred assignment</div></pre></td></tr></table></figure>
<p>可变变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = 5 // `Int` <span class="built_in">type</span> is inferred</div><div class="line">x += 1</div></pre></td></tr></table></figure>
<p>顶层变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val PI = 3.14</div><div class="line">var x = 0</div><div class="line"></div><div class="line">fun <span class="function"><span class="title">incrementX</span></span>() &#123; </div><div class="line">    x += 1 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><p>在 kotlin 中, classes 可以有属性. 它们可通过使用 <code>var</code> 关键字来声明为可变的(mutable), 或 通过 <code>val</code> 关键字来声明为不可变的.</p>
<p>完整的语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<p>当声明为 <code>var</code> (可变) 的属性时, 它默认会有 <code>getter</code> 和 <code>setter</code> 方法.</p>
<p>当声明为 <code>val</code> (不可变) 的属性时, 它只有 <code>getter</code> 而没有 <code>setter</code> 方法</p>
<p>自定义访问方法: (1.1及之后版本, 可以忽略 属性的类型, 由 getter 方法来推断)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val isEmpty: Boolean</div><div class="line">    get() = this.size == 0</div></pre></td></tr></table></figure>
<p>自定义setter 方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringRepresentation: String</div><div class="line">    get() = this.toString()</div><div class="line">    <span class="built_in">set</span>(value) &#123;</div><div class="line">        setDataFromString(value) // parses the string and assigns values to other properties</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果你想修改 <code>getter 和 setter</code> 的访问权限或想注入它, 但又不想修改默认实现, 则可以这样子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var setterVisibility: String = <span class="string">"abc"</span></div><div class="line">    private <span class="built_in">set</span> // the setter is private and has the default implementation</div><div class="line"></div><div class="line">var setterWithAnnotation: Any? = null</div><div class="line">    @Inject <span class="built_in">set</span> // annotate the setter with Inject</div></pre></td></tr></table></figure>
<h4 id="compile-time-constant"><a href="#compile-time-constant" class="headerlink" title="compile time constant"></a>compile time constant</h4><p>如果属性的值可以在编译时就可以确定的话, 则它可以标记为编译时常量. 通过 <code>const</code> 修饰符来设置.这样子的属性, 要完全满足以下要求:</p>
<ul>
<li>顶层或者是一个 object 的成员.</li>
<li>初始值的类型为 <code>String</code> 或为 基本数据类型 (primitive type)</li>
<li>没有自定义的 <code>setter</code> 方法</li>
</ul>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const val SUBSYSTEM_DEPRECATED: String = <span class="string">"This subsystem is deprecated"</span></div></pre></td></tr></table></figure>
<h4 id="late-initialized-属性和变量-延迟初始化"><a href="#late-initialized-属性和变量-延迟初始化" class="headerlink" title="late initialized 属性和变量(延迟初始化)"></a>late initialized 属性和变量(延迟初始化)</h4><p>通过 <code>lateinit</code> 修饰符来修饰.</p>
<p>条件为</p>
<ul>
<li>var 声明的变量</li>
<li>必须是 non null </li>
<li>没有自定义的 getter 和 setter</li>
<li>1.2及之后版本, 则为 顶层的属性 以及 local variable</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyTest &#123;</div><div class="line">    lateinit var subject: TestSubject</div><div class="line"></div><div class="line">    @SetUp fun <span class="function"><span class="title">setup</span></span>() &#123;</div><div class="line">        subject = TestSubject()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test fun <span class="function"><span class="title">test</span></span>() &#123;</div><div class="line">        subject.method()  // dereference directly</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测 <code>lateinit</code> 修改的变量是否初始化(1.2版本开始)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (foo::bar.isInitialized) &#123;</div><div class="line">    println(foo.bar)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>行注释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//</div></pre></td></tr></table></figure>
<p>块注释<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>不同于Java, 在 kotlin 中, 块注释可以嵌套的~</p>
<h2 id="使用字符串模板"><a href="#使用字符串模板" class="headerlink" title="使用字符串模板"></a>使用字符串模板</h2><p>字符串可以包含 <code>template expression</code>, 它是以一个 <code>$</code> 开头以及一个简单的变量或表达式组成的.</p>
<p>它在在 <code>raw string</code> 中也支持.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val price = <span class="string">""</span><span class="string">"</span></div><div class="line"><span class="variable">$&#123;'$'&#125;</span>9.99</div><div class="line">"<span class="string">""</span></div></pre></td></tr></table></figure>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">// simple name <span class="keyword">in</span> template:</div><div class="line">val s1 = <span class="string">"a is <span class="variable">$a</span>"</span> </div><div class="line"></div><div class="line">a = 2</div><div class="line">// arbitrary expression <span class="keyword">in</span> template:</div><div class="line">val s2 = <span class="string">"<span class="variable">$&#123;s1.replace("is", "was")&#125;</span>, but now is <span class="variable">$a</span>"</span></div></pre></td></tr></table></figure>
<h2 id="Null-安全的"><a href="#Null-安全的" class="headerlink" title="Null 安全的"></a>Null 安全的</h2><p>Kotlin 的类型系统被设计于消除 null 引用的危险性的. 它可以区分是否一个引用能否为 <code>null</code> 的:</p>
<p>允许为 null:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var b: String? = <span class="string">"abc"</span></div><div class="line">b = null // ok</div></pre></td></tr></table></figure>
<p>不允许为 null:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a: String = <span class="string">"abc"</span></div><div class="line">a = null // compilation error</div></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><h4 id="检查-null-条件"><a href="#检查-null-条件" class="headerlink" title="检查 null 条件"></a>检查 null 条件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (b != null) &#123;</div><div class="line">    //<span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="安全调用"><a href="#安全调用" class="headerlink" title="安全调用"></a>安全调用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b?.length</div></pre></td></tr></table></figure>
<p>这种也可用于调用链中~</p>
<h3 id="elvis-操作符"><a href="#elvis-操作符" class="headerlink" title="elvis 操作符"></a>elvis 操作符</h3><p><code>?:</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val l = b?.length ?: -1</div><div class="line"></div><div class="line">等于同下面</div><div class="line"></div><div class="line">val l: Int = <span class="keyword">if</span> (b != null) b.length <span class="keyword">else</span> -1</div></pre></td></tr></table></figure>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="!! 操作符"></a>!! 操作符</h3><p>如果引用为 null , 它会自动抛出 NPE 异常.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val l = b!!.length</div></pre></td></tr></table></figure>
<h3 id="安全转换"><a href="#安全转换" class="headerlink" title="安全转换"></a>安全转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val aInt: Int? = a as? Int</div></pre></td></tr></table></figure>
<p>当目标对象不能正确转换时, 它会返回 <code>null</code></p>
<h3 id="nullable-类型的集合"><a href="#nullable-类型的集合" class="headerlink" title="nullable 类型的集合"></a>nullable 类型的集合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)</div><div class="line">val intList: List&lt;Int&gt; = nullableList.filterNotNull()</div></pre></td></tr></table></figure>
<h2 id="使用类型检查和自动转换"><a href="#使用类型检查和自动转换" class="headerlink" title="使用类型检查和自动转换"></a>使用类型检查和自动转换</h2><p><code>is</code> 操作符检查一个表达式是否是一种类型的实例. 如果一个 immutable 的 local variable 或 属性 是已经检测为特定类型的话, 则不需要显式转换它. 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">    <span class="keyword">if</span> (obj is String) &#123;</div><div class="line">        // `obj` is automatically cast to `String` <span class="keyword">in</span> this branch</div><div class="line">        <span class="built_in">return</span> obj.length</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // `obj` is still of <span class="built_in">type</span> `Any` outside of the <span class="built_in">type</span>-checked branch</div><div class="line">    <span class="built_in">return</span> null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用-for-循环"><a href="#使用-for-循环" class="headerlink" title="使用 for 循环"></a>使用 for 循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) <span class="built_in">print</span>(item)</div><div class="line"></div><div class="line"><span class="keyword">for</span> (item: Int <span class="keyword">in</span> ints) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</div><div class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用-while-循环"><a href="#使用-while-循环" class="headerlink" title="使用 while 循环"></a>使用 while 循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (x &gt; 0) &#123;</div><div class="line">    x--</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    val y = retrieveData()</div><div class="line">&#125; <span class="keyword">while</span> (y != null) // y is visible here!</div></pre></td></tr></table></figure>
<h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><p>用于替换C系的 <code>switch</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    1 -&gt; <span class="built_in">print</span>(<span class="string">"x == 1"</span>)</div><div class="line">    2 -&gt; <span class="built_in">print</span>(<span class="string">"x == 2"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; &#123; // Note the block</div><div class="line">        <span class="built_in">print</span>(<span class="string">"x is neither 1 nor 2"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">when (x) &#123;</div><div class="line">    0, 1 -&gt; <span class="built_in">print</span>(<span class="string">"x == 0 or x == 1"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; <span class="built_in">print</span>(<span class="string">"otherwise"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">when (x) &#123;</div><div class="line">    <span class="keyword">in</span> 1..10 -&gt; <span class="built_in">print</span>(<span class="string">"x is in the range"</span>)</div><div class="line">    <span class="keyword">in</span> validNumbers -&gt; <span class="built_in">print</span>(<span class="string">"x is valid"</span>)</div><div class="line">    !<span class="keyword">in</span> 10..20 -&gt; <span class="built_in">print</span>(<span class="string">"x is outside the range"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; <span class="built_in">print</span>(<span class="string">"none of the above"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用-range"><a href="#使用-range" class="headerlink" title="使用 range"></a>使用 range</h2><p>范围操作符: <code>..</code></p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> 1..10) &#123; // equivalent of 1 &lt;= i &amp;&amp; i &lt;= 10</div><div class="line">    println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反序:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 4 downTo 1) <span class="built_in">print</span>(i) // prints <span class="string">"4321"</span></div></pre></td></tr></table></figure>
<p>步进</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1..4 step 2) <span class="built_in">print</span>(i) // prints <span class="string">"13"</span></div></pre></td></tr></table></figure>
<p>until:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1 until 10) &#123; // i <span class="keyword">in</span> [1, 10), 10 is excluded</div><div class="line">     println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</div><div class="line">    println(item)</div><div class="line">&#125;</div><div class="line"></div><div class="line">when &#123;</div><div class="line">    <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</div><div class="line">    <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">fruits</div><div class="line">.filter &#123; it.startsWith(<span class="string">"a"</span>) &#125;</div><div class="line">.sortedBy &#123; it &#125;</div><div class="line">.map &#123; it.toUpperCase() &#125;</div><div class="line">.forEach &#123; println(it) &#125;</div></pre></td></tr></table></figure>
<h2 id="创建基本类和它们的实例"><a href="#创建基本类和它们的实例" class="headerlink" title="创建基本类和它们的实例"></a>创建基本类和它们的实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val rectangle = Rectangle(5.0, 2.0) //no <span class="string">'new'</span> keyword required</div><div class="line">val triangle = Triangle(3.0, 4.0, 5.0)</div></pre></td></tr></table></figure>
<h1 id="源码组织"><a href="#源码组织" class="headerlink" title="源码组织"></a>源码组织</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>在一个混合语言的项目里, Kotlin 的源码应该与 Java 的源码的根目录相同, 并且跟随相同的目录结构(每个文件应该保存到 <code>package</code> 语句中的相应的目录)</p>
<p>在一个纯 Kotlin 的项目里, 建议目录的结构跟随在一个忽略了公共的根 package 下面(例如, 如果项目里所有的代码都是在 <code>org.example.kotlin</code> 包及子包下面, 则这些文件应该直接放在源码的根目录下, 并且文件在 <code>org.example.kotlin.foo.bar</code> 的则应该在源码的子目录 <code>foo/bar</code> 下面)</p>
<h2 id="源码文件名"><a href="#源码文件名" class="headerlink" title="源码文件名"></a>源码文件名</h2><p>如果一个 kotlin 文件包含一个单独的 class , 则文件名应该与 class 的名字相同, 并带有 <code>.kt</code> 后缀.</p>
<p>如果包含多个 class, 或仅有顶层的声明的话, 则相应选择一个适当的描述的文件名. 使用 <code>CamelHumps</code> (驼峰命名), 例如 <code>ProcessDeclarations.kt</code></p>
<p>文件名应该选择适当描述文件内容的名称的. 因此, 应该避免使用无意义的单词, 例如 <code>Util</code> 这种文件名.</p>
<h2 id="源文件的组织"><a href="#源文件的组织" class="headerlink" title="源文件的组织"></a>源文件的组织</h2><p>我们鼓励将多个声明(class, 层顶的函数或属性)放在同一个源文件里, 只要这些声明相关性是比较话的话, 并且文件的大小也比较适合(不超出几百行代码)</p>
<p>特别地, 当为某个 class 定义 <code>extension</code> 函数时, 则建议将它们放在同一个文件中.</p>
<h2 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h2><p>通常, class 的内容是按以下顺序来保存的:</p>
<ul>
<li>属性声明和初始化块</li>
<li>构造器</li>
<li>方法声明</li>
<li>引用的对象</li>
</ul>
<p>不要将方法声明按字母或可见性来排序!</p>
<p>也不要分隔普通的方法和 extension 方法</p>
<p>相应的, 应该将相关性的放在一起, 以便人从上到下阅读源码时可以根据逻辑顺序来阅读.</p>
<p>将嵌套的类放在紧接着使用这些类的下面. 如果这些嵌套类是用于外部调用并且没有在内部使用的, 则放在类的最后.</p>
<h2 id="接口实现层"><a href="#接口实现层" class="headerlink" title="接口实现层"></a>接口实现层</h2><p>如果实现一个接口的话, 则将实现的成员按接口中的相同顺序来保存.</p>
<p>如果有需要的话, 则为这些实现插入额外的私有方法.</p>
<h2 id="重载层"><a href="#重载层" class="headerlink" title="重载层"></a>重载层</h2><p>总是将重载的方法放在一起!</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>跟随Java的命名规则. 特别地:</p>
<p>名包总是小写的, 并且不要使用下划线(<code>org.example.myproject</code>). 通常不建议使用多单词的名字, 但如果你确实需要, 你也可以简单地将它们拼接在一起, 或者使用驼峰式( <code>com.example.myProject</code>)</p>
<h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>函数名, 属性名, 以及 local variable 应该以小写字母开头, 并且使用驼峰的形式(没有下划线).</p>
<p>例外:</p>
<p>工厂方法(用于创建类实例)的, 方法名可以跟类名一样(大写字母开头的驼峰)</p>
<h3 id="测试方法的命名"><a href="#测试方法的命名" class="headerlink" title="测试方法的命名"></a>测试方法的命名</h3><blockquote>
<p>仅在测试方法中</p>
</blockquote>
<p>它可以接受用反单引号里带有空格的方法名.(注意: 这种方法暂不被 Android Runtime 支持)</p>
<p>带有下划线的命名也允许在测试代码中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyTestCase &#123;</div><div class="line">     @Test fun `ensure everything works`() &#123;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     @Test fun <span class="function"><span class="title">ensureEverythingWorks_onAndroid</span></span>() &#123;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h2><p>常量的命名, 应该以大写和以下划线分隔的名字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const val MAX_COUNT = 8</div><div class="line">val USER_NAME_FIELD = <span class="string">"UserName"</span></div></pre></td></tr></table></figure>
<p>其他的使用普通的驼峰命名(小写开头)</p>
<h1 id="修饰符的顺序"><a href="#修饰符的顺序" class="headerlink" title="修饰符的顺序"></a>修饰符的顺序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public / protected / private / internal</div><div class="line">expect / actual</div><div class="line">final / open / abstract / sealed / const</div><div class="line">external</div><div class="line">override</div><div class="line">lateinit</div><div class="line">tailrec</div><div class="line">vararg</div><div class="line"><span class="built_in">suspend</span></div><div class="line">inner</div><div class="line">enum / annotation</div><div class="line">companion</div><div class="line">inline</div><div class="line">infix</div><div class="line">operator</div><div class="line">data</div></pre></td></tr></table></figure>
<h1 id="Lable"><a href="#Lable" class="headerlink" title="Lable"></a>Lable</h1><p>在 Kotlin 中任意的语句都可以标记有一个 <code>label</code> .</p>
<p>语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">labelName@</div></pre></td></tr></table></figure>
<p>即名称最后加个 <code>@</code></p>
<p>使用 label 时, 则将 <code>@</code> 放在名称开头即可:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@labelName</div></pre></td></tr></table></figure>
<h2 id="return-中使用-label"><a href="#return-中使用-label" class="headerlink" title="return 中使用 label"></a>return 中使用 label</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">    listOf(1, 2, 3, 4, 5).forEach lit@&#123;</div><div class="line">        <span class="keyword">if</span> (it == 3) <span class="built_in">return</span>@lit // <span class="built_in">local</span> <span class="built_in">return</span> to the <span class="built_in">caller</span> of the lambda, i.e. the forEach loop</div><div class="line">        <span class="built_in">print</span>(it)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(<span class="string">" done with explicit label"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>return @a 1</code></p>
<p>表示在label <code>@a</code> 中进行 <code>return 1</code></p>
<h1 id="class-和-继承"><a href="#class-和-继承" class="headerlink" title="class 和 继承"></a>class 和 继承</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>通过关键字 <code>class</code> 来定义</p>
<p>组成:</p>
<ul>
<li>class name</li>
<li>class header(指定它的参数, 主构造器, primary constructor 等)</li>
<li>class body(用大括号包着)</li>
</ul>
<p>header 和 body 都是可选的. 如果没有 body 的话:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Empty</div></pre></td></tr></table></figure>
<p>即可.</p>
<h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person constructor(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果主构造器没有任何的 annotation 或 可见性修饰符, 则可以省略 <code>constructor</code> 关键字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Person(firstName: String) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 主构造器不能有任何代码!初始化代码可以被放在 <code>initializer blocks</code> (初始化块中). 它是以 <code>init</code> 关键字为开头的代码块.它的初始化顺序, 就是代码出现的顺序. 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class InitOrderDemo(name: String) &#123;</div><div class="line">    val firstProperty = <span class="string">"First property: <span class="variable">$name</span>"</span>.also(::println)</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"First initializer block that prints <span class="variable">$&#123;name&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    val secondProperty = <span class="string">"Second property: <span class="variable">$&#123;name.length&#125;</span>"</span>.also(::println)</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"Second initializer block that prints <span class="variable">$&#123;name.length&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个非抽象的 class 没有声明任何的构造器(主或次), 它会自动生成一个没有参数的 <code>public</code> 的主构造器. 如果你需要修改这访问权限的话, 则要显式地这样子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class DontCreateMe private <span class="function"><span class="title">constructor</span></span> () &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在JVM平台上, 如果主构造器的所有参数都有默认值的话, 编译器会生成一个额外的无参构造器, 它将使用这些默认值.这使 Kotlin 使用一些类似 Jackson 或 JPA 这些库更方便, 它们需要通过无参构造器来创建实例.</p>
</blockquote>
<h3 id="次构造器"><a href="#次构造器" class="headerlink" title="次构造器"></a>次构造器</h3><blockquote>
<p>可以有多个</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    constructor(parent: Person) &#123;</div><div class="line">        parent.children.add(this)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个 class 有一个 主构造器, 则每一个次构造器都需要委派给(delegate to)主构造器: 通过 <code>this</code> 关键字来做:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person(val name: String) &#123;</div><div class="line">    constructor(name: String, parent: Person) : this(name) &#123;</div><div class="line">        parent.children.add(this)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>注意, 初始化块相当于主构造器的一部分. 委派给主构造器会相当于在次构造器的第一条语句中执行.</p>
<p>因此, 所有在初始化块的代码, 都会在次构器代码之前执行! 即使 class 没有主构造器也一样!</p>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val invoice = Invoice()</div><div class="line"></div><div class="line">val customer = Customer(<span class="string">"Joe Smith"</span>)</div></pre></td></tr></table></figure>
<p>注意, 不需要 <code>new</code> 关键字.</p>
<h3 id="class-成员"><a href="#class-成员" class="headerlink" title="class 成员"></a>class 成员</h3><p>它可以包含</p>
<ul>
<li>构造器来初始化块</li>
<li>函数</li>
<li>属性</li>
<li>嵌套以及内部类</li>
<li>对象声明</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>所有 Kotlin 类都有一个公共的超类 <code>Any</code> .</p>
<p>注意, <code>Any</code> 不是 <code>java.lang.Object</code> . 特别地, 它没有任何的成员, 除了 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> 之外.</p>
<p>显式指定继承的类, 可以在 class header 之后加个冒号. 如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Derived(p: Int) : Base(p)</div></pre></td></tr></table></figure>
<p>注意, 默认情况下, 所有的 Kotlin 类都是 <code>final</code> 的(基于 Effective Java 的第17条规则).</p>
<p>可以通过 <code>open</code> 来改变:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open class Base(p: Int)</div></pre></td></tr></table></figure>
<p>这样子, 就允许该类被继承了.</p>
<p>如果子类有一个主构造器, 则父类可以且必需被初始化在正确的地方.</p>
<p>如果子类没有主构造器, 则每个子类中的次构造器必须通过 <code>super</code> 关键字来进行委派另一个构造器来初始化.</p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>不同于Java, Kotlin 中要求显式使用 <code>override</code> 来指明这是一个重写的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Base &#123;</div><div class="line">    open fun <span class="function"><span class="title">v</span></span>() &#123;&#125;</div><div class="line">    fun <span class="function"><span class="title">nv</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class Derived() : <span class="function"><span class="title">Base</span></span>() &#123;</div><div class="line">    override fun <span class="function"><span class="title">v</span></span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个标记为 <code>override</code> 的成员, 本身是 <code>open</code> 的. 如果你想禁止它重写, 则可使用 <code>final</code> 关键字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open class AnotherDerived() : <span class="function"><span class="title">Base</span></span>() &#123;</div><div class="line">    final override fun <span class="function"><span class="title">v</span></span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>重写属性也必须显式使用 <code>override</code>, 并且它们必须有一个兼容的类型.</p>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Foo &#123;</div><div class="line">    open val x: Int <span class="function"><span class="title">get</span></span>() &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar1 : <span class="function"><span class="title">Foo</span></span>() &#123;</div><div class="line">    override val x: Int = ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 也可以在主构造器中使用 <code>override</code> 关键字作为属性声明的一部分.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Foo &#123;</div><div class="line">    val count: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar1(override val count: Int) : Foo</div><div class="line"></div><div class="line">class Bar2 : Foo &#123;</div><div class="line">    override var count: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子类初始化顺序"><a href="#子类初始化顺序" class="headerlink" title="子类初始化顺序"></a>子类初始化顺序</h3><p>父类先初始化完, 再到子类.</p>
<p>这意味着, 在父类构造器执行期间, 子类中的声明的或重写的属性还没有初始化完毕的. 如果这些属性用在父类的初始化逻辑(不管是直接还是间接, 还是其他通过重写 <code>open</code> 成员来实现), 它可能会导致不正确的行为, 或者一个 runtime 失败.</p>
<p>设计一个父类时, 因此你应该避免在构造器, 属性初始化以及<code>init</code> 代码块中使用 <code>open</code> 的成员.</p>
<h3 id="调用父类的实现"><a href="#调用父类的实现" class="headerlink" title="调用父类的实现"></a>调用父类的实现</h3><p>通过 <code>super</code> 关键字来调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">open class Foo &#123;</div><div class="line">    open fun <span class="function"><span class="title">f</span></span>() &#123; println(<span class="string">"Foo.f()"</span>) &#125;</div><div class="line">    open val x: Int get() = 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar : <span class="function"><span class="title">Foo</span></span>() &#123;</div><div class="line">    override fun <span class="function"><span class="title">f</span></span>() &#123; </div><div class="line">        super.f()</div><div class="line">        println(<span class="string">"Bar.f()"</span>) </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override val x: Int get() = super.x + 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一个内部类中, 访问外部类的父类时, 可以通过 <code>super</code> 并带有外部类的名来实现: <code>super@Outer</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Bar : <span class="function"><span class="title">Foo</span></span>() &#123;</div><div class="line">    override fun <span class="function"><span class="title">f</span></span>() &#123; /* ... */ &#125;</div><div class="line">    override val x: Int get() = 0</div><div class="line">    </div><div class="line">    inner class Baz &#123;</div><div class="line">        fun <span class="function"><span class="title">g</span></span>() &#123;</div><div class="line">            super@Bar.f() // Calls Foo<span class="string">'s implementation of f()</span></div><div class="line">            println(super@Bar.x) // Uses Foo's implementation of x<span class="string">'s getter</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h4><p><em>如果一个类从它的直接父类中继承了多个相同的成员, 则它必须重写它自己的成员, 并且提供它自己的实现.</em> </p>
<p>为了指明使用哪个父类的实现, 可以通过 <code>super</code> 关键字, 并在带有 <code>类括号</code> 里写上父类类型. 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">open class A &#123;</div><div class="line">    open fun <span class="function"><span class="title">f</span></span>() &#123; <span class="built_in">print</span>(<span class="string">"A"</span>) &#125;</div><div class="line">    fun <span class="function"><span class="title">a</span></span>() &#123; <span class="built_in">print</span>(<span class="string">"a"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;</div><div class="line">    fun <span class="function"><span class="title">f</span></span>() &#123; <span class="built_in">print</span>(<span class="string">"B"</span>) &#125; // interface members are <span class="string">'open'</span> by default</div><div class="line">    fun <span class="function"><span class="title">b</span></span>() &#123; <span class="built_in">print</span>(<span class="string">"b"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C() : A(), B &#123;</div><div class="line">    // The compiler requires f() to be overridden:</div><div class="line">    override fun <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">        super&lt;A&gt;.f() // call to A.f()</div><div class="line">        super&lt;B&gt;.f() // call to B.f()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="abstract-class"><a href="#abstract-class" class="headerlink" title="abstract class"></a>abstract class</h3><p>注意, 我们不需要标记一个抽象类或函数为 <code>open</code> 的, 默认就是 <code>open</code> 的.</p>
<p>我们可以将一个非抽象的 <code>open</code> 成员, 重写为 <code>abstract</code> 的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Base &#123;</div><div class="line">    open fun <span class="function"><span class="title">f</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Derived : <span class="function"><span class="title">Base</span></span>() &#123;</div><div class="line">    override abstract fun f()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Companion-Objects"><a href="#Companion-Objects" class="headerlink" title="Companion Objects"></a>Companion Objects</h3><p>在 Kotlin 中, 不像 Java 或 C# , 它没有静态方法的. 绝大部分情况下, 建议简单地使用 包级别的方法来代码~</p>
<p>如果你需要写一个函数可以不需要通过类实例就可以调用的话. 你可以将它写为一个 <code>object declaration</code> 的成员即可.</p>
<p>更具体地, 你可以声明一个 <code>companion object</code> 在你的类里. 这样, 你就可以像Java调用静态方法那样来调用它了.</p>
<h3 id="Object-Declaration"><a href="#Object-Declaration" class="headerlink" title="Object Declaration"></a>Object Declaration</h3><p>单例某几种情况下是非常有用的, 在 Kotlin 中, 你可以非常方便地声明单例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object DataProviderManager &#123;</div><div class="line">    fun registerDataProvider(provider: DataProvider) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    val allDataProviders: Collection&lt;DataProvider&gt;</div><div class="line">        get() = // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这被称为 <code>object declaration</code> , 并且它总是一个 <code>object</code> 关键字后接一个名字的.</p>
<p><code>object declaration</code> 的初始化是线程安全的.</p>
<h3 id="companion-object"><a href="#companion-object" class="headerlink" title="companion object"></a>companion object</h3><p>在一个类内部进行 <code>object declaration</code> 的话, 它可以用 <code>companion</code> 关键字来标记.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object Factory &#123;</div><div class="line">        fun create(): MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后可以这样子简化调用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val instance = MyClass.create()</div></pre></td></tr></table></figure>
<p>声明时, <code>companion object</code> 的名称可以省略:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure>
<h1 id="属性和字段"><a href="#属性和字段" class="headerlink" title="属性和字段"></a>属性和字段</h1><h2 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h2><p><code>var</code> 的表示是可变的(mutable)<br><code>val</code> 的表示是只读的(read-only)</p>
<h2 id="setter-和-getter"><a href="#setter-和-getter" class="headerlink" title="setter 和 getter"></a>setter 和 getter</h2><p>完整的语法为 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringRepresentation: String</div><div class="line">    get() = this.toString()</div><div class="line">    <span class="built_in">set</span>(value) &#123;</div><div class="line">        setDataFromString(value) // parses the string and assigns values to other properties</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h1><p>与 Java 8 非常相似.</p>
<p>它可以包含抽象方法, 也可以有方法实现. 使用 <code>interface</code> 关键字来定义:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface MyInterface &#123;</div><div class="line">    fun bar()</div><div class="line">    fun <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">      // optional body</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Child : MyInterface &#123;</div><div class="line">    override fun <span class="function"><span class="title">bar</span></span>() &#123;</div><div class="line">        // body</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h2><p>可以为抽象的, 也可以提供访问器实现.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">interface MyInterface &#123;</div><div class="line">    val prop: Int // abstract</div><div class="line"></div><div class="line">    val propertyWithImplementation: String</div><div class="line">        get() = <span class="string">"foo"</span></div><div class="line"></div><div class="line">    fun <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">        <span class="built_in">print</span>(prop)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child : MyInterface &#123;</div><div class="line">    override val prop: Int = 29</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重写时的冲突解决"><a href="#重写时的冲突解决" class="headerlink" title="重写时的冲突解决"></a>重写时的冲突解决</h2><p>参考上面说的.</p>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p><code>getter</code> 总是与属性的访问性是一致的!一共有4种:</p>
<ul>
<li><code>private</code> : 仅声明的地方可以访问.</li>
<li><code>protected</code> : 在顶层的声明中不可用.</li>
<li><code>internal</code> : 在相同的 <code>module</code> 中可见.</li>
<li><code>public</code> (默认就是 <code>public</code>) : 所有代码都可以访问.</li>
</ul>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>一个 <code>module</code> 表示是一个 kotlin 文件编译在一起的集合:</p>
<ul>
<li>一个 intellij 的 moduel</li>
<li>一个 maven 项目</li>
<li>一个 gradle 文件源的集合</li>
<li>一个 ant task 编译的集合</li>
</ul>
<h1 id="extension-扩展"><a href="#extension-扩展" class="headerlink" title="extension 扩展"></a>extension 扩展</h1><h2 id="extension-function-1"><a href="#extension-function-1" class="headerlink" title="extension function"></a>extension function</h2><p>为了声明一个扩展函数, 我们需要有一个接收者类型的前缀, 例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">    val tmp = this[index1] // <span class="string">'this'</span> corresponds to the list</div><div class="line">    this[index1] = this[index2]</div><div class="line">    this[index2] = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>this</code> 关键字对应于接收者的对象. 现在, 我们可以调用在任意的<code>MutableList&lt;Int&gt;</code> 中调用这个方法了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val l = mutableListOf(1, 2, 3)</div><div class="line">l.swap(0, 2) // <span class="string">'this'</span> inside <span class="string">'swap()'</span> will hold the value of <span class="string">'l'</span></div></pre></td></tr></table></figure>
<p>当然, 也可以是泛型版本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">    val tmp = this[index1] // <span class="string">'this'</span> corresponds to the list</div><div class="line">    this[index1] = this[index2]</div><div class="line">    this[index2] = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extension-是静态解析的"><a href="#extension-是静态解析的" class="headerlink" title="extension 是静态解析的"></a>extension 是静态解析的</h2><p>扩展函数实际上并不修改它们扩展的 class 的. 通过定义一个 extension, 你并没有插入新的成员到该 class 中, 但仅是在该类型的变量中通过 <code>.</code> 来调用这个方法而已.</p>
<p>我们想强调的是,  extension function 是通过静态分发的.</p>
<p>注意, 如果 class 中有一个成员函数, 以及一个 extension 函数, 它们的方法签名一样的话,则 <code>member always wins!</code></p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    fun <span class="function"><span class="title">foo</span></span>() &#123; println(<span class="string">"member"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun C.<span class="function"><span class="title">foo</span></span>() &#123; println(<span class="string">"extension"</span>) &#125;</div></pre></td></tr></table></figure>
<p>它总是会输出 <code>member</code>.</p>
<p>然而, 可以通过 extension 来重载 (overload) 成员函数(即相同的方法名, 但签名不一样)</p>
<h2 id="nullable-接收者"><a href="#nullable-接收者" class="headerlink" title="nullable 接收者"></a>nullable 接收者</h2><p>你可以在方法内部检查是否为 <code>null</code> 例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun Any?.toString(): String &#123;</div><div class="line">    <span class="keyword">if</span> (this == null) <span class="built_in">return</span> <span class="string">"null"</span></div><div class="line">    // after the null check, <span class="string">'this'</span> is autocast to a non-null <span class="built_in">type</span>, so the toString() below</div><div class="line">    // resolves to the member <span class="keyword">function</span> of the Any class</div><div class="line">    <span class="built_in">return</span> toString()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extension-属性"><a href="#extension-属性" class="headerlink" title="extension 属性"></a>extension 属性</h2><p>类似函数, kotlin 支持扩展属性:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</div><div class="line">    get() = size - 1</div></pre></td></tr></table></figure>
<h2 id="Companion-Object-Extensions"><a href="#Companion-Object-Extensions" class="headerlink" title="Companion Object Extensions"></a>Companion Object Extensions</h2><p>如果一个 class 有 <code>companion object</code> , 你也可以为它定义一个扩展函数和扩展属性:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123; &#125;  // will be called <span class="string">"Companion"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">fun MyClass.Companion.<span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass.foo()</div></pre></td></tr></table></figure>
<h2 id="定义-extension-作为成员"><a href="#定义-extension-作为成员" class="headerlink" title="定义 extension 作为成员"></a>定义 extension 作为成员</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class D &#123;</div><div class="line">    fun <span class="function"><span class="title">bar</span></span>() &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C &#123;</div><div class="line">    fun <span class="function"><span class="title">baz</span></span>() &#123; ... &#125;</div><div class="line"></div><div class="line">    fun D.<span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">        bar()   // calls D.bar</div><div class="line">        baz()   // calls C.baz</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun <span class="built_in">caller</span>(d: D) &#123;</div><div class="line">        d.foo()   // call the extension <span class="keyword">function</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Data-classes"><a href="#Data-classes" class="headerlink" title="Data classes"></a>Data classes</h1><p>我们经常会创建一些主要用来持有数据的 class . 这在 Kotlin 中称为 <code>data</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class User(val name: String, val age: Int)</div></pre></td></tr></table></figure>
<p>编译器会自动为声明在主构造器(primary constructor) 中的属性创建以下</p>
<ul>
<li><code>equals() / hashCode()</code> 方法对</li>
<li><code>toString()</code> , 形式为 <code>User(name=John, age=42)</code></li>
<li><code>componentN()</code> 函数</li>
<li><code>copy()</code> 函数</li>
</ul>
<p>前提条件(要全满足)</p>
<ul>
<li>主构造器至少要有一个参数</li>
<li>所以主构造器的参数需要标记为 <code>val</code> 或 <code>var</code></li>
<li>data class 不能为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或 <code>inner</code> 的.</li>
<li>(1.1之前), data class 仅实现接口</li>
</ul>
<p>生成代码的规则:</p>
<ul>
<li>如果显式实现了 <code>equals()</code>, <code>hashCode()</code> 或 <code>toString()</code> , 或父类的这些实现是 <code>final</code> 的话, 则不会生成这些代码了, 它会用现成的代码</li>
<li>如果父类有 <code>componentN()</code> 函数, 并且为 <code>open</code> 以及返回兼容的类型, 则会生成的代码会重写父类的. 如果不能重写, 则会报错.</li>
<li>从一个有 <code>copy()</code> 函数的类中派生的话, 在 1.2 中是标记为 <code>deprecated</code> 的, 并且 在 1.3 中是禁止的.</li>
<li>不允许显式实现 <code>componentN()</code> 和 <code>copy()</code> 函数</li>
</ul>
<h2 id="在-body-里声明属性"><a href="#在-body-里声明属性" class="headerlink" title="在 body 里声明属性"></a>在 body 里声明属性</h2><p>注意: 只有在主构造器的参数的, 才会在 <code>toString()</code> , <code>equals()</code> 和 <code>hashCode()</code>, <code>copy()</code> 中使用到. 如果是在 body 中声明的, 则不会使用.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data class Person(val name: String) &#123;</div><div class="line">    var age: Int = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="copying"><a href="#copying" class="headerlink" title="copying"></a>copying</h2><p>有时, 我们经常需要 copy 一个对象, 但仅修改某些属性, 又不想影响原有对象. <code>copy()</code> 方法就是为它使用的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</div><div class="line"></div><div class="line"></div><div class="line">val jack = User(name = <span class="string">"Jack"</span>, age = 1)</div><div class="line">val olderJack = jack.copy(age = 2)</div></pre></td></tr></table></figure>
<h1 id="Sealed-Classes"><a href="#Sealed-Classes" class="headerlink" title="Sealed Classes"></a>Sealed Classes</h1><p><code>sealed classes</code> 是用来表示有限的 class 继承的, 它的值仅可以为一些有限集合之中的一种类型, 并且不能为其他类型.</p>
<p>在某种意义上说, 它是一个扩展的枚举类, 值的集合是限定为枚举类, 但每个枚举常量仅存在一个单例, 而 <code>sealed class</code> 的子类则可以有多个实例状态.</p>
<p>声明一个 <code>sealed class</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sealed class Expr</div></pre></td></tr></table></figure>
<p><code>sealed class</code> 可以有子类, 但所有这些子类, 必须在声明 <code>sealed class</code> 的文件内!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sealed class Expr</div><div class="line">data class Const(val number: Double) : Expr()</div><div class="line">data class Sum(val e1: Expr, val e2: Expr) : Expr()</div><div class="line">object NotANumber : Expr()</div></pre></td></tr></table></figure>
<p><code>sealed class</code> 不允许有非 private 的构造器(默认就是 <code>private</code> 的)</p>
<p><code>sealed class</code> 主要用在 <code>when</code> 表达式~</p>
<h1 id="generic-泛型"><a href="#generic-泛型" class="headerlink" title="generic 泛型"></a>generic 泛型</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Box&lt;T&gt;(t: T) &#123;</div><div class="line">    var value = t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果参数是可以被解析的话, 则可以忽略类型:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val box = Box(1) // 1 has <span class="built_in">type</span> Int, so the compiler figures out that we are talking about Box&lt;Int&gt;</div></pre></td></tr></table></figure>
<h1 id="嵌套类和内部类"><a href="#嵌套类和内部类" class="headerlink" title="嵌套类和内部类"></a>嵌套类和内部类</h1><p>嵌套类:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Outer &#123;</div><div class="line">    private val bar: Int = 1</div><div class="line">    class Nested &#123;</div><div class="line">        fun foo() = 2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val demo = Outer.Nested().foo() // == 2</div></pre></td></tr></table></figure>
<p>内部类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Outer &#123;</div><div class="line">    private val bar: Int = 1</div><div class="line">    inner class Inner &#123;</div><div class="line">        fun foo() = bar</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匿名内部类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.addMouseListener(object: <span class="function"><span class="title">MouseAdapter</span></span>() &#123;</div><div class="line">    override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">                                                                                                            </div><div class="line">    override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum class Direction &#123;</div><div class="line">    NORTH, SOUTH, WEST, EAST</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum class Color(val rgb: Int) &#123;</div><div class="line">        RED(0xFF0000),</div><div class="line">        GREEN(0x00FF00),</div><div class="line">        BLUE(0x0000FF)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匿名类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum class ProtocolState &#123;</div><div class="line">    WAITING &#123;</div><div class="line">        override fun signal() = TALKING</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    TALKING &#123;</div><div class="line">        override fun signal() = WAITING</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    abstract fun signal(): ProtocolState</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="object-expression-和-declaration"><a href="#object-expression-和-declaration" class="headerlink" title="object expression 和 declaration"></a>object expression 和 declaration</h1><p>有时, 我们需要创建一个对象来小小修改一些 class 的, 不用为它显式声明一个新的子类. 在Java中, 处理这种情况的, 是用匿名内部类. Kotlin 则是用 <code>object expression</code> 和 <code>object declaration</code></p>
<p>为现有的类型创建一个匿名类型, 可以这样子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.addMouseListener(object : <span class="function"><span class="title">MouseAdapter</span></span>() &#123;</div><div class="line">    override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果父类是多种类型的话, 则用逗号隔开:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">open class A(x: Int) &#123;</div><div class="line">    public open val y: Int = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;...&#125;</div><div class="line"></div><div class="line">val ab: A = object : A(1), B &#123;</div><div class="line">    override val y = 15</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但我们仅需要一个对象的话, 则我们可以简单地:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">    val adHoc = object &#123;</div><div class="line">        var x: Int = 0</div><div class="line">        var y: Int = 0</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(adHoc.x + adHoc.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>object declaration , 参考前面.</p>
<h1 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation 委托"></a>Delegation 委托</h1><p><code>delegation</code> 模式提供了一个比较好的修改实现的方式. <code>Kotlin</code> 则原生支持它. 一个 <code>Derived</code> 类, 可以继承一个接口 <code>Base</code> 并且委托它所有的 <code>public</code> 方法到一个指定的对象:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">interface Base &#123;</div><div class="line">    fun <span class="built_in">print</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BaseImpl(val x: Int) : Base &#123;</div><div class="line">    override fun <span class="function"><span class="title">print</span></span>() &#123; <span class="built_in">print</span>(x) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived(b: Base) : Base by b</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val b = BaseImpl(10)</div><div class="line">    Derived(b).<span class="built_in">print</span>() // prints 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>by</code> 子句, 在 <code>Derived</code> class 中, 指示 <code>b</code> 将被内部保存在 <code>Derived</code> 中, 并且编译器将生成所有 <code>Base</code> 类的方法到 <code>b</code></p>
<p>注意, <code>override</code> : 编译器会使用你的 <code>override</code> 的实现来委托.</p>
<h1 id="Delegated-Properties"><a href="#Delegated-Properties" class="headerlink" title="Delegated Properties"></a>Delegated Properties</h1><p>有一些公共的属性, 尽管我们可以手工多次实现它, 但更好的是实现它一次, 然后放到一个库中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Example &#123;</div><div class="line">    var p: String by Delegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class Delegate &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        <span class="built_in">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="variable">$&#123;property.name&#125;</span>' to me!"</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</div><div class="line">        println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="variable">$&#123;property.name&#125;</span>' in <span class="variable">$thisRef</span>."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标准的-delegates"><a href="#标准的-delegates" class="headerlink" title="标准的 delegates"></a>标准的 delegates</h2><ul>
<li>Lazy</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val lazyValue: String by lazy &#123;</div><div class="line">    println(<span class="string">"computed!"</span>)</div><div class="line">    <span class="string">"Hello"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(lazyValue)</div><div class="line">    println(lazyValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Observable</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import kotlin.properties.Delegates</div><div class="line"></div><div class="line">class User &#123;</div><div class="line">    var name: String by Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</div><div class="line">        prop, old, new -&gt;</div><div class="line">        println(<span class="string">"<span class="variable">$old</span> -&gt; <span class="variable">$new</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val user = User()</div><div class="line">    user.name = <span class="string">"first"</span></div><div class="line">    user.name = <span class="string">"second"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Storing-Properties-in-a-Map"><a href="#Storing-Properties-in-a-Map" class="headerlink" title="Storing Properties in a Map"></a>Storing Properties in a Map</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class User(val map: Map&lt;String, Any?&gt;) &#123;</div><div class="line">    val name: String by map</div><div class="line">    val age: Int     by map</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">val user = User(mapOf(</div><div class="line">    <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</div><div class="line">    <span class="string">"age"</span>  to 25</div><div class="line">))</div></pre></td></tr></table></figure>
<h1 id="higher-order-function-和-lambda-1"><a href="#higher-order-function-和-lambda-1" class="headerlink" title="higher-order function 和 lambda"></a>higher-order function 和 lambda</h1><p><code>higher-order function</code> 是这样一种函数: 它可以作为参数或函数返回值. 例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T &#123;</div><div class="line">    lock.lock()</div><div class="line">    try &#123;</div><div class="line">        <span class="built_in">return</span> body()</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">        lock.unlock()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="it-隐式的单一的参数名字"><a href="#it-隐式的单一的参数名字" class="headerlink" title="it : 隐式的单一的参数名字"></a><code>it</code> : 隐式的单一的参数名字</h2><p>如果 lambda 只有一个参数时, 可以这样子简写(并且不需要 <code>-&gt;</code>):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ints.map &#123; it * 2 &#125;</div></pre></td></tr></table></figure>
<h2 id="忽略参数-1-1-版本开始"><a href="#忽略参数-1-1-版本开始" class="headerlink" title="_ : 忽略参数:(1.1 版本开始)"></a><code>_</code> : 忽略参数:(1.1 版本开始)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.forEach &#123; _, value -&gt; println(<span class="string">"<span class="variable">$value</span>!"</span>) &#125;</div></pre></td></tr></table></figure>
<h2 id="inline-function-1"><a href="#inline-function-1" class="headerlink" title="inline function"></a>inline function</h2><p>它一般可增强性能.</p>
<h2 id="lambda-expression-和-匿名函数"><a href="#lambda-expression-和-匿名函数" class="headerlink" title="lambda expression 和 匿名函数"></a>lambda expression 和 匿名函数</h2><p>它们都是 <code>function iteral</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max(strings, &#123; a, b -&gt; a.length &lt; b.length &#125;)</div></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun(x: Int, y: Int): Int = x + y</div><div class="line"></div><div class="line">fun(x: Int, y: Int): Int &#123;</div><div class="line">    <span class="built_in">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">ints.filter(fun(item) = item &gt; 0)</div></pre></td></tr></table></figure>
<h2 id="closures"><a href="#closures" class="headerlink" title="closures"></a>closures</h2><p>一个 <code>lambda expression</code> 或 <code>anonymous function</code> 可以访问它的 <code>closure</code> (例如, 一个声明在外部的变量) 不同于Java, 捕获的变量可以被修改(Java中, 只能访问 <code>final</code> 的变量)</p>
<h2 id="function-literal-与-receiver"><a href="#function-literal-与-receiver" class="headerlink" title="function literal 与 receiver"></a>function literal 与 receiver</h2><p>Kotlin 允许为它提供一个接收者:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum : Int.(other: Int) -&gt; Int</div></pre></td></tr></table></figure>
<p>然后可以这样子调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.sum(2)</div></pre></td></tr></table></figure>
<h1 id="inline-function-2"><a href="#inline-function-2" class="headerlink" title="inline function"></a>inline function</h1><p>使用 <code>higher-order function</code> 都会加重运行时的负担: 每一个函数都是一个 <code>object</code>, 并且它会捕获一个 <code>closure</code>, 例如, 可访问的函数体的变量. 内存分配以及虚拟调用都会增加 runtime 的负载.</p>
<p>但多数情况下, 可以通过 <code>inline lambda expression</code>  来减少这种负载.</p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lock(l) &#123; foo() &#125;</div></pre></td></tr></table></figure>
<h2 id="开启-inline"><a href="#开启-inline" class="headerlink" title="开启 inline"></a>开启 <code>inline</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T): T &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h2><p>如果你只想指定的某些参数不进行 inline:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="inline-properties"><a href="#inline-properties" class="headerlink" title="inline properties"></a>inline properties</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val foo: Foo</div><div class="line">    inline get() = Foo()</div><div class="line"></div><div class="line">var bar: Bar</div><div class="line">    get() = ...</div><div class="line">    inline <span class="built_in">set</span>(v) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h1 id="destructuring-declaration"><a href="#destructuring-declaration" class="headerlink" title="destructuring declaration"></a>destructuring declaration</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val (name, age) = person</div></pre></td></tr></table></figure>
<p>以上就是析构的声明语法. 它由编译器自动生成以下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val name = person.component1()</div><div class="line">val age = person.component2()</div></pre></td></tr></table></figure>
<p>也可以在 <code>for</code> 循环里使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ((a, b) <span class="keyword">in</span> collection) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h2 id="从一个函数中返回2个值"><a href="#从一个函数中返回2个值" class="headerlink" title="从一个函数中返回2个值"></a>从一个函数中返回2个值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">data class Result(val result: Int, val status: Status)</div><div class="line">fun <span class="keyword">function</span>(...): Result &#123;</div><div class="line">    // computations</div><div class="line">    </div><div class="line">    <span class="built_in">return</span> Result(result, status)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Now, to use this <span class="keyword">function</span>:</div><div class="line">val (result, status) = <span class="keyword">function</span>(...)</div></pre></td></tr></table></figure>
<h2 id="在-map-中使用"><a href="#在-map-中使用" class="headerlink" title="在 map 中使用"></a>在 map 中使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</div><div class="line">   // <span class="keyword">do</span> something with the key and the value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在-lambda-中使用"><a href="#在-lambda-中使用" class="headerlink" title="在 lambda 中使用"></a>在 lambda 中使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">map.mapValues &#123; entry -&gt; <span class="string">"<span class="variable">$&#123;entry.value&#125;</span>!"</span> &#125;</div><div class="line">map.mapValues &#123; (key, value) -&gt; <span class="string">"<span class="variable">$value</span>!"</span> &#125;</div></pre></td></tr></table></figure>
<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Kotlin 是会区分 <code>mutable</code> 和 <code>immutable</code> 的集合的.</p>
<p>区分一个 mutable 的 <code>read-only</code> 视图, 和一个真正 <code>immutable</code> 的集合是非常重要的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)</div><div class="line">val readOnlyView: List&lt;Int&gt; = numbers</div><div class="line">println(numbers)        // prints <span class="string">"[1, 2, 3]"</span></div><div class="line">numbers.add(4)</div><div class="line">println(readOnlyView)   // prints <span class="string">"[1, 2, 3, 4]"</span></div><div class="line">readOnlyView.clear()    // -&gt; does not compile</div><div class="line"></div><div class="line">val strings = hashSetOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>)</div><div class="line">assert(strings.size == 3)</div></pre></td></tr></table></figure>
<h1 id="this-expression"><a href="#this-expression" class="headerlink" title="this expression"></a>this expression</h1><ul>
<li>在一个 class 成员内, <code>this</code> 引用的是当前class 的 object 对象</li>
<li>在一个 <code>expression function</code> 或 <code>function literal with receiver</code> 中, <code>this</code> 表示 <code>receiver</code> 参数(即 <code>.</code> 左边类型的对象)</li>
</ul>
<p>如果 <code>this</code> 没有限定符, 则它引用的是 <code>内部最近的作用域</code>. 为了使 <code>this</code> 引用其他作用域的, 可以使用 <code>label qualifiers</code> </p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class A &#123; // implicit label @A</div><div class="line">    inner class B &#123; // implicit label @B</div><div class="line">        fun Int.<span class="function"><span class="title">foo</span></span>() &#123; // implicit label @foo</div><div class="line">            val a = this@A // A<span class="string">'s this</span></div><div class="line">            val b = this@B // B's this</div><div class="line"></div><div class="line">            val c = this // foo()<span class="string">'s receiver, an Int</span></div><div class="line">            val c1 = this@foo // foo()'s receiver, an Int</div><div class="line"></div><div class="line">            val funLit = lambda@ fun String.() &#123;</div><div class="line">                val d = this // funLit<span class="string">'s receiver</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            val funLit2 = &#123; s: String -&gt;</div><div class="line">                // foo()'s receiver, since enclosing lambda expression</div><div class="line">                // doesn<span class="string">'t have any receiver</span></div><div class="line">                val d1 = this</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="equality-相等"><a href="#equality-相等" class="headerlink" title="equality 相等"></a>equality 相等</h1><ul>
<li><code>equals()</code> : structural equality (a == b, 它会被翻译为 <code>a?.equals(b) ?: (b === null)</code>)</li>
<li>引用相等: 使用 <code>===</code> 或 <code>!==</code> 来判断</li>
</ul>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>参考 <a href="http://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="noopener">doc</a></p>
<h1 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h1><p>声明注解</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">annotation class Fancy</div><div class="line"></div><div class="line">@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,</div><div class="line">        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)</div><div class="line">@Retention(AnnotationRetention.SOURCE)</div><div class="line">@MustBeDocumented</div><div class="line">annotation class Fancy</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Fancy class Foo &#123;</div><div class="line">    @Fancy fun baz(@Fancy foo: Int): Int &#123;</div><div class="line">        <span class="built_in">return</span> (@Fancy 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Type-aliases-类型别名"><a href="#Type-aliases-类型别名" class="headerlink" title="Type aliases 类型别名"></a>Type aliases 类型别名</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typealias NodeSet = Set&lt;Network.Node&gt;</div><div class="line"></div><div class="line">typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;</div></pre></td></tr></table></figure>

                                
    </div>
</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持 emacsist</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/img/wxpay.jpeg" alt="">
          </li>
        
          <li class="item">
            <img src="/img/alipay.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/books/"
              rel="noopener noreferrer"
              target="_self"
              >
              阅读
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
