<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Go学习 | emacsist</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="golang,go," />
  

  <meta name="description" content="安装多个版本的 goGVM Go依赖管理与 GOPATH 的关系.GOPATH环境变量中可以包含多个目录。 go get  这种方式，它会将依赖下载在$GOPATH环境变量中的第一个目录中. 自己对Go中包的理解编写代码时，使用的`package`，表示代码所在的包名。  引用时，`import package`，这个`package`表示相对于`GOPATH`中的`src`目录下的目录名，多层目">
<meta name="keywords" content="golang,go">
<meta property="og:type" content="article">
<meta property="og:title" content="Go学习">
<meta property="og:url" content="https://emacsist.github.io/2016/10/18/Go学习/index.html">
<meta property="og:site_name" content="emacsist">
<meta property="og:description" content="安装多个版本的 goGVM Go依赖管理与 GOPATH 的关系.GOPATH环境变量中可以包含多个目录。 go get  这种方式，它会将依赖下载在$GOPATH环境变量中的第一个目录中. 自己对Go中包的理解编写代码时，使用的`package`，表示代码所在的包名。  引用时，`import package`，这个`package`表示相对于`GOPATH`中的`src`目录下的目录名，多层目">
<meta property="og:updated_time" content="2017-11-03T08:15:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go学习">
<meta name="twitter:description" content="安装多个版本的 goGVM Go依赖管理与 GOPATH 的关系.GOPATH环境变量中可以包含多个目录。 go get  这种方式，它会将依赖下载在$GOPATH环境变量中的第一个目录中. 自己对Go中包的理解编写代码时，使用的`package`，表示代码所在的包名。  引用时，`import package`，这个`package`表示相对于`GOPATH`中的`src`目录下的目录名，多层目">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b870e52c6cd914cb42627e4a706700b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  

  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/books/"
            rel="noopener noreferrer"
            target="_self"
            >
            阅读
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装多个版本的-go"><span class="toc-text">安装多个版本的 go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go依赖管理与-GOPATH-的关系"><span class="toc-text">Go依赖管理与 GOPATH 的关系.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自己对Go中包的理解"><span class="toc-text">自己对Go中包的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang中的字符串拼接"><span class="toc-text">Golang中的字符串拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode中调试Go"><span class="toc-text">vscode中调试Go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go单元测试"><span class="toc-text">Go单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单元测试某个指定的方法"><span class="toc-text">单元测试某个指定的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单元测试递归执行"><span class="toc-text">单元测试递归执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于单元测试中的-Log-，-Logf"><span class="toc-text">关于单元测试中的 Log()， Logf()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang中类似Java中的toString-功能"><span class="toc-text">Golang中类似Java中的toString()功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int64-to-String"><span class="toc-text">int64 to String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过反射遍历结构体"><span class="toc-text">通过反射遍历结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将json字段串自动转化生成struct结构"><span class="toc-text">将json字段串自动转化生成struct结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json-字符串-转换为-struct"><span class="toc-text">json 字符串 转换为 struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-对象-转换为json字符串"><span class="toc-text">struct 对象 转换为json字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数中是否是指针的区别"><span class="toc-text">参数中是否是指针的区别:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用Go包"><span class="toc-text">常用Go包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见错误"><span class="toc-text">常见错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-ContentLength-xxx-with-Body-length-yyy"><span class="toc-text">http: ContentLength=xxx with Body length yyy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cannot-define-new-methods-on-non-local-type"><span class="toc-text">cannot define new methods on non-local type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#can’t-load-package-import-cycle-not-allowed"><span class="toc-text">can’t load package: import cycle not allowed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#too-many-arguments-to-return"><span class="toc-text">too many arguments to return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-is-pointer-to-interface-not-interface"><span class="toc-text">*interface {} is pointer to interface, not interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cannot-use-nil-as-type-xxx"><span class="toc-text">cannot use nil as type xxx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#found-packages-xxxx-and-xxxx-xxxx-in-xxxx"><span class="toc-text">found packages xxxx () and xxxx (xxxx) in xxxx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-结构体的继承"><span class="toc-text">struct 结构体的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go中的字符串转换为字符数组"><span class="toc-text">Go中的字符串转换为字符数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang中顶级的JSON数组字符串转换为json对象"><span class="toc-text">Golang中顶级的JSON数组字符串转换为json对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个自定义的error"><span class="toc-text">创建一个自定义的error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json数组转换为map"><span class="toc-text">json数组转换为map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go交叉编译"><span class="toc-text">Go交叉编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见错误-1"><span class="toc-text">常见错误:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下交叉编译Mac"><span class="toc-text">Linux下交叉编译Mac</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS常量以及ARCH常量"><span class="toc-text">OS常量以及ARCH常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go打包静态资源"><span class="toc-text">Go打包静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用编译选项"><span class="toc-text">常用编译选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#去掉调试信息"><span class="toc-text">去掉调试信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看优化的信息-内联-inline-信息、逃逸分析等"><span class="toc-text">查看优化的信息(内联 inline 信息、逃逸分析等)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组与slice-区别"><span class="toc-text">数组与slice 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go中使用-redis"><span class="toc-text">Go中使用 redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-中使用-gorm-与-mysql-交互"><span class="toc-text">Go 中使用 gorm 与 mysql 交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-中使用-rabbitmq"><span class="toc-text">go 中使用 rabbitmq</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go中long与timestamp-json的转换"><span class="toc-text">go中long与timestamp json的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-中找出实现了某接口的代码"><span class="toc-text">Go 中找出实现了某接口的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang中实现优雅关闭程序"><span class="toc-text">Golang中实现优雅关闭程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检查程序监控了哪些信号"><span class="toc-text">检查程序监控了哪些信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang中的struct-tag使用"><span class="toc-text">Golang中的struct tag使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#限制Goalng的HTTP-工作线程-goroutine"><span class="toc-text">限制Goalng的HTTP 工作线程(goroutine)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么我的内存没有被操作系统回收？"><span class="toc-text">为什么我的内存没有被操作系统回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang1-8-中的优雅关闭-http"><span class="toc-text">Golang1.8 中的优雅关闭 http</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按-github-风格的项目组织结构"><span class="toc-text">按 github 风格的项目组织结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩编译后的文件大小"><span class="toc-text">压缩编译后的文件大小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#去掉符号信息"><span class="toc-text">去掉符号信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-upx-压缩"><span class="toc-text">使用 upx 压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang-中的-web"><span class="toc-text">Golang 中的 web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#短声明注意"><span class="toc-text">短声明注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang-中格式化日期"><span class="toc-text">Golang 中格式化日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-中发送登录请求（保持-cookie"><span class="toc-text">Go 中发送登录请求（保持 cookie)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-中提交表单"><span class="toc-text">Go 中提交表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#logrus-设置日志时间格式"><span class="toc-text">logrus 设置日志时间格式</span></a></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-Go学习" class="article article-type-post" itemprop="blogPost">
    <header class="article-header">
        <h1 class="post-title">
            Go学习
        </h1>

        <div class="article-meta">
            <span>
        <i class="icon-calendar"></i>
        <span>2016.10.18</span>
            </span>

            
                <span class="article-author">
          <i class="icon-user"></i>
          <span>emacsist</span>
                </span>
                

                    
    <span class="article-category">
    <i class="icon-list"></i>
    
      <a class="tag-item" href="/tags/#go">
        <span class="tag-name">go</span>
    <span class="tag-size">( 15 )</span>
    </a>
    
      <a class="tag-item" href="/tags/#golang">
        <span class="tag-name">golang</span>
    <span class="tag-size">( 19 )</span>
    </a>
    

        </span>
        

                        

                                

                                        

        </div>
    </header>

    <div class="article-content">
        
                            <h2 id="安装多个版本的-go"><a href="#安装多个版本的-go" class="headerlink" title="安装多个版本的 go"></a>安装多个版本的 go</h2><p><a href="https://github.com/moovweb/gvm" target="_blank" rel="external">GVM</a></p>
<h2 id="Go依赖管理与-GOPATH-的关系"><a href="#Go依赖管理与-GOPATH-的关系" class="headerlink" title="Go依赖管理与 GOPATH 的关系."></a>Go依赖管理与 GOPATH 的关系.</h2><p><code>GOPATH</code>环境变量中可以包含多个目录。</p>
<pre><code class="bash">go get
</code></pre>
<p>这种方式，它会将依赖下载在<code>$GOPATH</code>环境变量中的第一个目录中.</p>
<h2 id="自己对Go中包的理解"><a href="#自己对Go中包的理解" class="headerlink" title="自己对Go中包的理解"></a>自己对Go中包的理解</h2><pre><code class="bash">编写代码时，使用的`package`，表示代码所在的包名。

引用时，`import package`，这个`package`表示相对于`GOPATH`中的`src`目录下的目录名，多层目录，使用`/`分隔。
一般来说，引用的`package`的名字，和你的最后一个目录的名字相同，但也可以不同。`import package`的名字，以所在包名的名字为准，而不是以目录名为准.
</code></pre>
<h2 id="Golang中的字符串拼接"><a href="#Golang中的字符串拼接" class="headerlink" title="Golang中的字符串拼接"></a>Golang中的字符串拼接</h2><pre><code class="bash">package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
)

func main() {
    var buffer bytes.Buffer

    for i := 0; i &lt; 1000; i++ {
        buffer.WriteString(&quot;a&quot;)
    }

    fmt.Println(buffer.String())
}
</code></pre>
<h2 id="vscode中调试Go"><a href="#vscode中调试Go" class="headerlink" title="vscode中调试Go"></a>vscode中调试Go</h2><pre><code class="bash">can&#39;t load package: package .: no buildable Go source files in /ihome/go/golang-weibo-sdk
exit status 1
</code></pre>
<p>这个问题是由于你没有将设置指向main.go的所在目录里.即，在Go的debug设置里，要类似如下：</p>
<pre><code class="bash">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [{
        &quot;name&quot;: &quot;Launch&quot;,
        &quot;type&quot;: &quot;go&quot;,
        &quot;request&quot;: &quot;launch&quot;,
        &quot;mode&quot;: &quot;debug&quot;,
        &quot;remotePath&quot;: &quot;&quot;,
        &quot;port&quot;: 2345,
        &quot;host&quot;: &quot;127.0.0.1&quot;,
        &quot;program&quot;: &quot;${workspaceRoot}/src/main&quot;,
        &quot;env&quot;: {},
        &quot;args&quot;: [],
        &quot;showLog&quot;: true
    }]
}
</code></pre>
<p>即，<code>program</code>要设置为指向Go的main函数文件所在的目录即可.</p>
<h2 id="Go单元测试"><a href="#Go单元测试" class="headerlink" title="Go单元测试"></a>Go单元测试</h2><p>必须要将命令行，先切换到要进行单元测试文件的目录的根目录。比如：</p>
<pre><code class="bash">$GOPATH/src/utils/myutil.go
$GOPATH/src/utils/myutil_test.go
</code></pre>
<p>要想进行 <code>myutil_test.go</code> 的单元测试，则先切换到目录<code>$GOPATH/src/utils</code>，然后在该目录下执行命令:<code>go test</code>即可。</p>
<h3 id="单元测试某个指定的方法"><a href="#单元测试某个指定的方法" class="headerlink" title="单元测试某个指定的方法"></a>单元测试某个指定的方法</h3><pre><code class="bash">go test -run mehtodName
</code></pre>
<h3 id="单元测试递归执行"><a href="#单元测试递归执行" class="headerlink" title="单元测试递归执行"></a>单元测试递归执行</h3><pre><code class="bash">进入到$GOPATH的根目录，然后按以下方式执行即可:
go test com.github.emacsist.weibosdk/api...
</code></pre>
<h3 id="关于单元测试中的-Log-，-Logf"><a href="#关于单元测试中的-Log-，-Logf" class="headerlink" title="关于单元测试中的 Log()， Logf()"></a>关于单元测试中的 Log()， Logf()</h3><p>默认的情况下，<code>go test</code>并不会输出这些， 如果需要的话，可以添加<code>go test -v</code>来输出详细信息.</p>
<h2 id="Golang中类似Java中的toString-功能"><a href="#Golang中类似Java中的toString-功能" class="headerlink" title="Golang中类似Java中的toString()功能"></a>Golang中类似Java中的<code>toString()</code>功能</h2><pre><code class="bash">package resp

import (
    &quot;fmt&quot;
)

// ErrorResp ： 错误码返回对象
type ErrorResp struct {
    Request   string `json:&quot;request&quot;`
    ErrorCode int32  `json:&quot;error_code&quot;`
    Error     string `json:&quot;error&quot;`
}

func (errorResp *ErrorResp) String() string {
    return fmt.Sprintf(&quot;request=%v\nErrorCode=%v\nError=%v\n&quot;, errorResp.Request, errorResp.ErrorCode, errorResp.Error)
}
</code></pre>
<p>即为它添加一个方法 <code>String() string</code>即可，这样子，在调用<code>fmt.Printf()</code>这些格式化打印时，就会自动调用对象的<code>String()</code>方法来打印了.</p>
<h2 id="int64-to-String"><a href="#int64-to-String" class="headerlink" title="int64 to String"></a>int64 to String</h2><pre><code class="bash">
import &quot;strconv&quot;

strconv.FormatInt(int64Value, 10)
</code></pre>
<h2 id="通过反射遍历结构体"><a href="#通过反射遍历结构体" class="headerlink" title="通过反射遍历结构体"></a>通过反射遍历结构体</h2><pre><code class="bash">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type Person struct {
    Age  int
    Name string
}

func main() {
    p := Person{Age: 10, Name: &quot;HelloWorld&quot;}

    refValue := reflect.ValueOf(&amp;p)

    fields := refValue.Elem()
    for i := 0; i &lt; fields.NumField(); i++ {
        field := fields.Field(i)
        fieldName := fields.Type().Field(i).Name
        fieldValue := field.Interface()
        fmt.Printf(&quot;fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
    }
}
</code></pre>
<p>要注意的是，<code>fieldName</code>是通过<code>fields</code>这个来获取的.</p>
<p>如果想要将字段的值转换为确定类型的值，则就可以这样子做:</p>
<pre><code class="bash">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type Person struct {
    Age  int
    Name string
}

func main() {
    p := Person{Age: 10, Name: &quot;HelloWorld&quot;}

    refValue := reflect.ValueOf(&amp;p)

    fields := refValue.Elem()
    for i := 0; i &lt; fields.NumField(); i++ {
        field := fields.Field(i)
        fieldName := fields.Type().Field(i).Name

        if field.Type().Name() == &quot;string&quot; {
            fieldValue := field.Interface().(string)
            fmt.Printf(&quot;string --&gt; fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
        } else if field.Type().Name() == &quot;int&quot; {
            fieldValue := field.Interface().(int)
            fmt.Printf(&quot;int --&gt; fieldName = %v, fieldValue = %v\n&quot;, fieldName, fieldValue)
        }

    }
}
</code></pre>
<h2 id="将json字段串自动转化生成struct结构"><a href="#将json字段串自动转化生成struct结构" class="headerlink" title="将json字段串自动转化生成struct结构"></a>将json字段串自动转化生成struct结构</h2><p><a href="http://json2struct.mervine.net/" target="_blank" rel="external">mervine.net</a><br><a href="https://mholt.github.io/json-to-go/" target="_blank" rel="external">mholt.github.io</a></p>
<h3 id="json-字符串-转换为-struct"><a href="#json-字符串-转换为-struct" class="headerlink" title="json 字符串 转换为 struct"></a>json 字符串 转换为 struct</h3><pre><code class="bash">import &quot;encoding/json&quot;

json.Unmarshal([]byte(body), &amp;status)
</code></pre>
<h3 id="struct-对象-转换为json字符串"><a href="#struct-对象-转换为json字符串" class="headerlink" title="struct 对象 转换为json字符串"></a>struct 对象 转换为json字符串</h3><pre><code class="bash">p为结构体变量
body, error := json.Marshal(p)
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="bash">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
)

// Person : test object
type Person struct {
    Name string
    Age  int
}

func changeValue(p Person) {
    p.Age = 10
}

func changeValue2(p *Person) {
    p.Age = 10
}

func main() {
    p := Person{Age: 1, Name: &quot;HelloWorld&quot;}
    changeValue(p)
    fmt.Printf(&quot;changeValue, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
    changeValue2(&amp;p)
    fmt.Printf(&quot;changeValue2, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)

    body, _ := json.Marshal(p)
    fmt.Printf(&quot;struct to json -&gt; %v\n&quot;, string(body))

    newP := Person{}
    fmt.Printf(&quot;newP age -&gt; %v\n&quot;, newP.Age)
    json.Unmarshal(body, &amp;newP)
    fmt.Printf(&quot;after json to struct -&gt; %v\n&quot;, newP.Age)
}
</code></pre>
<p>输出的结果为</p>
<pre><code class="bash">[Running] go run &quot;/ihome/go/golang-weibo-sdk/src/main/main.go&quot;
changeValue, name -&gt;HelloWorld, age -&gt; 1
changeValue2, name -&gt;HelloWorld, age -&gt; 10
struct to json -&gt; {&quot;Name&quot;:&quot;HelloWorld&quot;,&quot;Age&quot;:10}
newP age -&gt; 0
after json to struct -&gt; 10

[Done] exited with code=0 in 0.13 seconds
</code></pre>
<h2 id="参数中是否是指针的区别"><a href="#参数中是否是指针的区别" class="headerlink" title="参数中是否是指针的区别:"></a>参数中是否是指针的区别:</h2><pre><code class="bash">package main

import &quot;fmt&quot;

// Person : test object
type Person struct {
    Name string
    Age  int
}

func changeValue(p Person) {
    p.Age = 10
}

func changeValue2(p *Person) {
    p.Age = 10
}

func main() {
    p := Person{Age: 1, Name: &quot;HelloWorld&quot;}
    changeValue(p)
    fmt.Printf(&quot;changeValue, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
    changeValue2(&amp;p)
    fmt.Printf(&quot;changeValue2, name -&gt;%v, age -&gt; %v\n&quot;, p.Name, p.Age)
}
</code></pre>
<p>输出的结果为</p>
<pre><code class="bash">[Running] go run &quot;/ihome/go/golang-weibo-sdk/src/main/main.go&quot;
changeValue, name -&gt;HelloWorld, age -&gt; 1
changeValue2, name -&gt;HelloWorld, age -&gt; 10

[Done] exited with code=0 in 0.103 seconds
</code></pre>
<h2 id="常用Go包"><a href="#常用Go包" class="headerlink" title="常用Go包"></a>常用Go包</h2><pre><code class="bash">将struct转换为查询参数:
https://godoc.org/github.com/google/go-querystring/query
</code></pre>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="http-ContentLength-xxx-with-Body-length-yyy"><a href="#http-ContentLength-xxx-with-Body-length-yyy" class="headerlink" title="http: ContentLength=xxx with Body length yyy"></a>http: ContentLength=xxx with Body length yyy</h3><p>ContentLength=299 with Body length 367</p>
<pre><code class="bash">这一般是request对象前后的长度不一致（中间关闭了或处理了，导致后面的再次读取时不一致）
</code></pre>
<p>参考: <a href="http://stackoverflow.com/questions/31337891/net-http-http-contentlength-222-with-body-length-0" target="_blank" rel="external">stackoverflow</a></p>
<p>具体例子：我是在构造<code>request</code>时这样子写:</p>
<pre><code class="bash">    bodyBuf := &amp;bytes.Buffer{}
    bodyWriter := multipart.NewWriter(bodyBuf)

    v := reflect.ValueOf(param)
    fileds := v.Elem()

    paramsMap := netURL.Values{}
    //defer bodyWriter.Close()

    return http.NewRequest(&quot;POST&quot;, URL, bodyBuf)
</code></pre>
<p>关键是那行：<code>defer bodyWriter.Close()</code>，注释掉这行就可以了.</p>
<h3 id="cannot-define-new-methods-on-non-local-type"><a href="#cannot-define-new-methods-on-non-local-type" class="headerlink" title="cannot define new methods on non-local type"></a>cannot define new methods on non-local type</h3><pre><code class="bash">type MyRouter mux.Router

func (m *MyRouter) F() { ... }

或者

type MyRouter struct {
    *mux.Router
}

func (m *MyRouter) F() { ... }

...
r := &amp;MyRouter{router}
r.F()
</code></pre>
<h3 id="can’t-load-package-import-cycle-not-allowed"><a href="#can’t-load-package-import-cycle-not-allowed" class="headerlink" title="can’t load package: import cycle not allowed"></a>can’t load package: import cycle not allowed</h3><pre><code class="bash">package project/controllers/account
    imports project/controllers/base
    imports project/components/mux
    imports project/controllers/account
</code></pre>
<p>这表明有循环引用，循环引用的结果为:</p>
<pre><code class="bash">                  project/controllers/account
                     ^                    \    
                    /                      \
                   /                        \ 
                  /                         \/
         project/components/mux &lt;--- project/controllers/base
</code></pre>
<p>只要处理掉这个循环引用的一条链即可解决.</p>
<h3 id="too-many-arguments-to-return"><a href="#too-many-arguments-to-return" class="headerlink" title="too many arguments to return"></a>too many arguments to return</h3><p>一般来说，是你的方法签名中没有返回值，但你却进行了<code>return value</code>或者，你的方法签名中的返回值个数与<code>return 语句不匹配</code></p>
<h3 id="interface-is-pointer-to-interface-not-interface"><a href="#interface-is-pointer-to-interface-not-interface" class="headerlink" title="*interface {} is pointer to interface, not interface"></a>*interface {} is pointer to interface, not interface</h3><p>这个应该是你想在方法里进行泛型例如写成这样子:</p>
<pre><code class="bash">package helper

import &quot;reflect&quot;

// SetDefaultValues : 设置参数默认值
func SetDefaultValues(param *interface{}) {
    v := reflect.ValueOf(param)
    fileds := v.Elem()
    for i := 0; i &lt; fileds.NumField(); i++ {
        field := fileds.Field(i)
        // Ignore fields that don&#39;t have the same type as a string
        if field.Type().Name() == &quot;string&quot; {
            //如果是一个字符串对象
            if field.CanSet() {
                field.SetString(&quot;&quot;)
            }
        } else if field.Type().Name() == &quot;int&quot; || field.Type().Name() == &quot;int64&quot; {
            //如果是整型
            if field.CanSet() {
                field.SetInt(-1)
            }
        }
    }
}
</code></pre>
<p>但其实<code>interface{}</code>它表示的是接收任意的类型（包括指针），所以，这里不能这样子，应该修改参数为:<code>param interface{}</code>即可。</p>
<p>这样子，在调用方法时，传递的是指针，那么它就代表指针，传递的是普通类型，那就是普通类型。</p>
<h3 id="cannot-use-nil-as-type-xxx"><a href="#cannot-use-nil-as-type-xxx" class="headerlink" title="cannot use nil as type xxx"></a>cannot use nil as type xxx</h3><p>这表你的xxx并不能接受<code>nil</code>值。（一般来说，只有指针类型才能接受nil值)</p>
<h3 id="found-packages-xxxx-and-xxxx-xxxx-in-xxxx"><a href="#found-packages-xxxx-and-xxxx-xxxx-in-xxxx" class="headerlink" title="found packages xxxx () and xxxx (xxxx) in xxxx"></a>found packages xxxx () and xxxx (xxxx) in xxxx</h3><pre><code class="bash">┌─[sky@sky-linux] - [/ihome/go/golang-weibo-sdk/src/com.github.emacsist.weibosdk/api/business/status] - [2016-10-21 05:40:43]                              
└─[2] &lt;git:(master 3c154e3✱✈) &gt; go test -run StatusesRepostTimelineBizString                                                                               
../../../helper/HttpHelper.go:8:2: found packages resp (CommentsAndTotalNumberResp.go) and api (TagsTagsBatchOther.go) in /ihome/go/golang-weibo-sdk/src/co
m.github.emacsist.weibosdk/resp
</code></pre>
<p>Go语言规则，所有在同一个目录的源文件，都必须是同属一个包的.解决了这个问题就可以编译通过了.</p>
<h2 id="struct-结构体的继承"><a href="#struct-结构体的继承" class="headerlink" title="struct 结构体的继承"></a>struct 结构体的继承</h2><pre><code class="bash">// Person : test object
type Person struct {
    Name string
    Age  int
    Animal
}

type Animal struct {
    Colour string
    Name string
}
</code></pre>
<h2 id="Go中的字符串转换为字符数组"><a href="#Go中的字符串转换为字符数组" class="headerlink" title="Go中的字符串转换为字符数组"></a>Go中的字符串转换为字符数组</h2><pre><code class="bash">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(string(&quot;Hello&quot;[1]))              // ASCII only
    fmt.Println(string([]rune(&quot;Hello, 世界&quot;)[1])) // UTF-8
    fmt.Println(string([]rune(&quot;Hello, 世界&quot;)[8])) // UTF-8
}
</code></pre>
<p>千万要注意：<code>string[0:1]</code>这种形式是按<code>字节</code>来分隔的.<code>len(string)</code>返回的是字节数.<br>要操作字符的话，则要使用<code>rune</code>类型。</p>
<h2 id="Golang中顶级的JSON数组字符串转换为json对象"><a href="#Golang中顶级的JSON数组字符串转换为json对象" class="headerlink" title="Golang中顶级的JSON数组字符串转换为json对象"></a>Golang中顶级的JSON数组字符串转换为json对象</h2><pre><code class="bash">package main

import &quot;fmt&quot;
import &quot;encoding/json&quot;

type PublicKey struct {
    Id  int
    Key string
}

func main() {
    keysBody := []byte(`[{&quot;id&quot;: 1,&quot;key&quot;: &quot;-&quot;},{&quot;id&quot;: 2,&quot;key&quot;: &quot;-&quot;},{&quot;id&quot;: 3,&quot;key&quot;: &quot;-&quot;}]`)
    keys := make([]PublicKey, 0)
    json.Unmarshal(keysBody, &amp;keys)
    fmt.Printf(&quot;%#v&quot;, keys[2].Id)
}
</code></pre>
<h2 id="创建一个自定义的error"><a href="#创建一个自定义的error" class="headerlink" title="创建一个自定义的error"></a>创建一个自定义的error</h2><pre><code class="bash">import &quot;errors&quot;

errors.New(&quot;xx&quot;)
</code></pre>
<h2 id="json数组转换为map"><a href="#json数组转换为map" class="headerlink" title="json数组转换为map"></a>json数组转换为map</h2><pre><code class="bash">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
)

func main() {
    h := `[
    {
        &quot;221012100001985342&quot;: &quot;80后&quot;,
        &quot;weight&quot;: 50
    },
     {
        &quot;221012100001985342&quot;: &quot;80后1&quot;,
        &quot;weight&quot;: 51
    }
]`
    var hell []map[string]interface{}

    err := json.Unmarshal([]byte(h), &amp;hell)
    fmt.Printf(&quot;%v\n&quot;, err)
    fmt.Printf(&quot;%v\n&quot;, h)
    fmt.Printf(&quot;%v\n&quot;, hell)
}
</code></pre>
<h2 id="Go交叉编译"><a href="#Go交叉编译" class="headerlink" title="Go交叉编译"></a>Go交叉编译</h2><p>进入Go的安装目录<code>cd $GOROOT/src</code>，然后 选择要生成的目标构架的工具链:</p>
<pre><code class="bash"># windows64位
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash

# mac
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 ./make.bash

# linux 64
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 ./make.bash
</code></pre>
<h3 id="常见错误-1"><a href="#常见错误-1" class="headerlink" title="常见错误:"></a>常见错误:</h3><pre><code class="bash">┌─[sky@sky-linux] - [/ihome/go/go-current/src] - [2016-10-26 02:14:42]
└─[0] &lt;&gt; CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash
##### Building Go bootstrap tool.
cmd/dist
ERROR: Cannot find /home/sky/go1.4/bin/go.
Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4.
</code></pre>
<p>这表需要有一个<code>&gt;=1.4</code>的另一个<code>go</code>安装目录，并将<code>GOROOT_BOOTSTRAP</code>指向该目录即可.</p>
<h3 id="Linux下交叉编译Mac"><a href="#Linux下交叉编译Mac" class="headerlink" title="Linux下交叉编译Mac"></a>Linux下交叉编译Mac</h3><p><a href="http://stackoverflow.com/questions/34084597/cross-compilation-of-cgo-for-darwin-fails" target="_blank" rel="external">stackoverflow</a></p>
<h3 id="OS常量以及ARCH常量"><a href="#OS常量以及ARCH常量" class="headerlink" title="OS常量以及ARCH常量"></a>OS常量以及ARCH常量</h3><p><a href="https://github.com/golang/go/blob/master/src/go/build/syslist.go" target="_blank" rel="external">syslist</a></p>
<pre><code class="bash">
package build

const goosList = &quot;android darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows zos &quot;
const goarchList = &quot;386 amd64 amd64p32 arm armbe arm64 arm64be ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc s390 s390x sparc sparc64 &quot;
</code></pre>
<h2 id="Go打包静态资源"><a href="#Go打包静态资源" class="headerlink" title="Go打包静态资源"></a>Go打包静态资源</h2><p>安装: <code>go get -u github.com/jteeuwen/go-bindata/...</code></p>
<p><a href="https://github.com/jteeuwen/go-bindata" target="_blank" rel="external">go-bindata</a></p>
<p>假设<code>/tmp/go</code>是一个<code>$GOPATH</code>:</p>
<pre><code class="bash">┌─[sky@sky-linux] - [/tmp/go] - [2016-10-26 03:25:55]
└─[0] &lt;&gt; ll /tmp/go/src/nlp/dict
total 820K
-rw-r--r-- 1 sky sky 3.1K 10月 25 18:36 adv_full.txt
-rw-r--r-- 1 sky sky 3.2K 10月 25 18:36 adv.txt
-rw-r--r-- 1 sky sky 212K 10月 25 18:36 neg_full.txt
-rw-r--r-- 1 sky sky 305K 10月 25 18:36 neg.txt
-rw-r--r-- 1 sky sky  273 10月 25 18:36 not_full.txt
-rw-r--r-- 1 sky sky  287 10月 25 18:36 not.txt
-rw-r--r-- 1 sky sky 116K 10月 25 18:36 pos_full.txt
-rw-r--r-- 1 sky sky 149K 10月 25 18:36 pos.txt
-rw-r--r-- 1 sky sky 8.0K 10月 25 21:21 stp_full.txt
-rw-r--r-- 1 sky sky 8.0K 10月 25 18:36 stp.txt

┌─[sky@sky-linux] - [/tmp/go] - [2016-10-26 12:35:32]                                                                                                                      
└─[0] &lt;&gt; ./bin/go-bindata -o=src/nlp/asset/asset.go -pkg=asset -prefix &quot;/tmp/go/src/nlp/&quot; /tmp/go/src/nlp/dict
</code></pre>
<p>说明：</p>
<p><code>-o</code> : 表示生成静态资源的访问包的文件.<br><code>-pkg</code> ： 表示包名<br><code>-prefix</code> ： 表示自动添加的前缀。</p>
<p><code>/tmp/go/src/nlp/dict</code>表示静态资源的目录.如果要递归的话，可以这样子写: <code>/tmp/go/src/nlp/dict/...</code></p>
<p>成功后，可以看到生成了一个新的文件:<code>/tmp/go/src/nlp/asset/asset.go</code></p>
<p>使用例子:</p>
<pre><code class="bash">import (
    &quot;nlp/asset&quot;
)

func init() {
    fmt.Printf(&quot;init --&gt; %v\n&quot;, asset.AssetNames())
    loadDict(&quot;dict/adv_full.txt&quot;, &amp;advMap)
    loadDict(&quot;dict/neg_full.txt&quot;, &amp;negMap)
    loadDict(&quot;dict/not_full.txt&quot;, &amp;notMap)
    loadDict(&quot;dict/pos_full.txt&quot;, &amp;posMap)
    loadDict(&quot;dict/stp_full.txt&quot;, &amp;stpMap)
}

func loadDict(path string, dic *map[string]bool) {
    //&quot;dict/adv_full.txt&quot;
    data, _ := asset.Asset(path)
    bufferReader := bytes.NewReader(data)
    scan := bufio.NewScanner(bufferReader)
    for scan.Scan() {
        t := scan.Text()
        (*dic)[t] = true
    }
}
</code></pre>
<p>因为我们添加了<code>-prefix &quot;/tmp/go/src/nlp/&quot;</code>, 所以，我们可以直接这样子： <code>dict/adv_full.txt</code>的路径，就可以通过<code>asset.Asset(&quot;dict/adv_full.txt&quot;)</code>来访问我们的静态资源了.</p>
<h3 id="常用编译选项"><a href="#常用编译选项" class="headerlink" title="常用编译选项"></a>常用编译选项</h3><p>输出所有可用编译选项:</p>
<pre><code class="bash">go tool compile -help
</code></pre>
<h4 id="去掉调试信息"><a href="#去掉调试信息" class="headerlink" title="去掉调试信息"></a>去掉调试信息</h4><pre><code class="bash">go build -ldflags &#39;-w&#39;
</code></pre>
<h4 id="查看优化的信息-内联-inline-信息、逃逸分析等"><a href="#查看优化的信息-内联-inline-信息、逃逸分析等" class="headerlink" title="查看优化的信息(内联 inline 信息、逃逸分析等)"></a>查看优化的信息(内联 inline 信息、逃逸分析等)</h4><pre><code class="bash">go build -gcflags=-m
</code></pre>
<h2 id="数组与slice-区别"><a href="#数组与slice-区别" class="headerlink" title="数组与slice 区别"></a>数组与slice 区别</h2><pre><code class="bash">package main

import &quot;fmt&quot;

func main() {
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    sliceArray := arr[3:5]

    // 由此可知，slice是一种引用类型，因为它的第一个元素地址，与arr[3]的地址是一样的
    fmt.Printf(&quot;arr[3] address = %v\n&quot;, &amp;arr[3])
    fmt.Printf(&quot;sliceArray[0] address = %v\n&quot;, &amp;sliceArray[0])

    // len = 2
    fmt.Printf(&quot;len slice = %v\n&quot;, len(sliceArray))

    // cap = 7，cap的计算，是从第一个slice元素的位置，到原数组的结尾的长度.
    fmt.Printf(&quot;cap slice = %v\n&quot;, cap(sliceArray))

    // 因为sliceArray的cap为7,已经存在2个，那还可以容纳5个元素，这时引用的，还是arr数组，这样子append后，会修改arr的内容
    // arr 为 : [0 1 2 3 4 1 2 3 4 5]
    // sliceArray 为 : [3 4 1 2 3 4 5
    sliceArray = append(sliceArray, 1, 2, 3, 4, 5)

    // 当cap还在arr容纳范围之内时，slice指向的就是arr,通过打印他们的地址可知:
    fmt.Printf(&quot;arr[5] address = %v， value=%v\n&quot;, &amp;arr[6], arr[6])
    fmt.Printf(&quot;sliceArray[2] address = %v, value=%v\n&quot;, &amp;sliceArray[3], sliceArray[3])

    //但当sliceArray超过了cap时: [3 4 1 2 3 4 5 1 2 3 4 5]
    sliceArray = append(sliceArray, 1, 2, 3, 4, 5)
    // 可以发现，它指向了一个新的数组:因为他们的地址不同了.
    fmt.Printf(&quot;arr[5] address = %v， value=%v\n&quot;, &amp;arr[6], arr[6])
    fmt.Printf(&quot;sliceArray[2] address = %v, value=%v\n&quot;, &amp;sliceArray[3], sliceArray[3])
    fmt.Printf(&quot;cap slice = %v\n&quot;, cap(sliceArray))

    fmt.Printf(&quot;%v, %v\n&quot;, arr, sliceArray)
}
</code></pre>
<p>append超出cap之前与之后：</p>
<pre><code class="bash">package main

import &quot;fmt&quot;

func main() {
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    sliceArray := arr[3:5]
    sliceArray2 := arr[3:5]

    fmt.Printf(&quot;%v, %v, %v\n&quot;, arr, sliceArray, sliceArray2)
    fmt.Printf(&quot;%v, %v, %v\n&quot;, &amp;arr[3], &amp;sliceArray[0], &amp;sliceArray2[0])

    sliceArray = append(sliceArray, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)

    fmt.Printf(&quot;%v, %v, %v\n&quot;, arr, sliceArray, sliceArray2)
    fmt.Printf(&quot;%v, %v, %v\n&quot;, &amp;arr[3], &amp;sliceArray[0], &amp;sliceArray2[0])
}
</code></pre>
<h2 id="Go中使用-redis"><a href="#Go中使用-redis" class="headerlink" title="Go中使用 redis"></a>Go中使用 redis</h2><pre><code class="bash">package main

import (
    &quot;flag&quot;
    &quot;time&quot;

    &quot;fmt&quot;

    &quot;github.com/garyburd/redigo/redis&quot;
)

func newPool(server, password string) *redis.Pool {
    return &amp;redis.Pool{
        MaxIdle:     3,
        IdleTimeout: 240 * time.Second,
        Dial: func() (redis.Conn, error) {
            c, err := redis.Dial(&quot;tcp&quot;, server)
            if err != nil {
                return nil, err
            }
            if len(password) &gt; 0 {
                if _, err := c.Do(&quot;AUTH&quot;, password); err != nil {
                    c.Close()
                    return nil, err
                }
            }
            return c, err
        },
        TestOnBorrow: func(c redis.Conn, t time.Time) error {
            if time.Since(t) &lt; time.Minute {
                return nil
            }
            _, err := c.Do(&quot;PING&quot;)
            return err
        },
    }
}

var (
    pool          *redis.Pool
    redisServer   = flag.String(&quot;redisServer&quot;, &quot;:6379&quot;, &quot;&quot;)
    redisPassword = flag.String(&quot;redisPassword&quot;, &quot;&quot;, &quot;&quot;)
)

func main() {
    redisGet()
    redisPipline()
}

func redisGet() {
    redisConnection := pool.Get()
    defer redisConnection.Close()

    //如果这个不为空，表明获取链接时出错
    if redisConnection.Err() != nil {
        fmt.Printf(&quot;Hello World %v\n&quot;, redisConnection.Err().Error())
        return
    }

    val, err := redisConnection.Do(&quot;get&quot;, &quot;hello2&quot;)
    if err == nil {
        fmt.Printf(&quot;Hello %v\n&quot;, string(val.([]uint8)))
    } else {
        fmt.Printf(&quot;happen error : %v\n&quot;, err.Error())
    }

}

func redisPipline() {
    redisConnection := pool.Get()
    defer redisConnection.Close()

    //如果这个不为空，表明获取链接时出错
    if redisConnection.Err() != nil {
        fmt.Printf(&quot;Hello World %v\n&quot;, redisConnection.Err().Error())
        return
    }

    redisConnection.Send(&quot;get&quot;, &quot;hello&quot;)
    redisConnection.Send(&quot;get&quot;, &quot;hello1&quot;)
    redisConnection.Send(&quot;get&quot;, &quot;hello2&quot;)

    redisConnection.Flush()

    for i := 0; i &lt; 3; i++ {
        data, err := redisConnection.Receive()

        if err == nil &amp;&amp; redisConnection.Err() == nil {
            if data == nil {
                continue
            }
            fmt.Printf(&quot;Hello from pipline %v\n&quot;, string(data.([]uint8)))
            continue
        } else {
            fmt.Printf(&quot;Hello from pipline error %v\n&quot;, err.Error())
            break
        }
    }
    fmt.Printf(&quot;done\n&quot;)
}

func init() {
    flag.Parse()
    fmt.Printf(&quot;redis: server = %v, passwd = %v\n&quot;, *redisServer, *redisPassword)
    pool = newPool(*redisServer, *redisPassword)
    fmt.Printf(&quot;init redis connection pool ok\n&quot;)
}
</code></pre>
<p>注意，这个默认是<code>db 0</code>，如果想实现选择（虽然不推荐使用多个DB），可以按如下链接做:</p>
<p><a href="http://stackoverflow.com/questions/25708256/golang-selecting-db-on-a-redispool-in-redigo" target="_blank" rel="external">stackoverflow</a></p>
<h2 id="Go-中使用-gorm-与-mysql-交互"><a href="#Go-中使用-gorm-与-mysql-交互" class="headerlink" title="Go 中使用 gorm 与 mysql 交互"></a>Go 中使用 gorm 与 mysql 交互</h2><pre><code class="bash">package main

import (
    &quot;fmt&quot;

    &quot;time&quot;

    &quot;github.com/jinzhu/gorm&quot;
    _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;
)

type WbStatus struct {
    ID       int64 `gorm:&quot;primary_key&quot;`
    Text     string
    CreateAt time.Time
}

func (WbStatus) TableName() string {
    return &quot;wb_status&quot;
}

var db *gorm.DB

func main() {
    if db == nil {
        panic(&quot;db is nil&quot;)
    }
    var wbstatus WbStatus
    fmt.Printf(&quot;tableName = %v\n&quot;, wbstatus.TableName())
    db.First(&amp;wbstatus)

    fmt.Printf(&quot;rowId = %v\n&quot;, wbstatus.ID)
    fmt.Printf(&quot;createAt = %v\n&quot;, wbstatus.CreateAt)
    defer db.Close()
}

func init() {
    var err error
    db, err = gorm.Open(&quot;mysql&quot;, &quot;root:yang@(127.0.0.1:3306)/test?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;)
    if err != nil {
        fmt.Printf(&quot;init mysql error : %v\n&quot;, err.Error())
        panic(&quot;exit&quot;)
    }
    if db == nil {
        fmt.Printf(&quot;init mysql error : db is null\n&quot;)
        panic(&quot;exit&quot;)
    } else {
        fmt.Printf(&quot;init mysql  : db isnot null\n&quot;)
    }
    db.DB().SetMaxOpenConns(100)
    db.DB().SetMaxIdleConns(10)
    fmt.Printf(&quot;init mysql OK\n&quot;)
}
</code></pre>
<p><a href="http://jinzhu.me/gorm/" target="_blank" rel="external">gorm</a></p>
<h2 id="go-中使用-rabbitmq"><a href="#go-中使用-rabbitmq" class="headerlink" title="go 中使用 rabbitmq"></a>go 中使用 rabbitmq</h2><p><a href="https://github.com/streadway/amqp" target="_blank" rel="external">github amqp</a></p>
<p><a href="http://stackoverflow.com/questions/36179111/whether-to-create-connection-every-time-when-amqp-dial-is-threadsafe-or-not-in-g" target="_blank" rel="external">whether-to-create-connection-every-time-when-amqp-dial-is-threadsafe-or-not-in-golang</a></p>
<p><a href="https://ninefinity.org/post/ensuring-rabbitmq-connection-in-golang/" target="_blank" rel="external">ensuring-rabbitmq-connection-in-golang</a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><pre><code class="bash">ch, _ := mqCon.Channel()
    msgs, err := ch.Consume(
        config.Configuration.Rabbit.Listen,     // queue
        config.Configuration.Rabbit.ConsumerID, // consumer
        true,  // auto-ack
        false, // exclusive
        false, // no-local
        false, // no-wait
        nil,   // args
    )
</code></pre>
<p>如果你将<code>auto-ack</code>设置为true，则不用手工确认消息。如果设置为<code>false</code>，则必须手工调用:</p>
<pre><code class="bash">Delivery.Ack, Delivery.Reject or Delivery.Nack
</code></pre>
<p><a href="https://agocs.org/blog/2014/08/19/rabbitmq-best-practices-in-go/" target="_blank" rel="external">rabbitmq-best-practices-in-go</a></p>
<p><code>autoAck</code>:</p>
<blockquote>
<p>When autoAck (also known as noAck) is true, the server will acknowledge<br>deliveries to this consumer prior to writing the delivery to the network.  When<br>autoAck is true, the consumer should not call Delivery.Ack.  Automatically<br>acknowledging deliveries means that some deliveries may get lost if the<br>consumer is unable to process them after the server delivers them.</p>
</blockquote>
<h2 id="go中long与timestamp-json的转换"><a href="#go中long与timestamp-json的转换" class="headerlink" title="go中long与timestamp json的转换"></a>go中long与timestamp json的转换</h2><p><a href="http://stackoverflow.com/questions/31744970/convert-to-time-in-golang-from-milliseconds" target="_blank" rel="external">convert-to-time-in-golang-from-milliseconds</a></p>
<p><code>type A B只是让A获得B的内存模型而已。A不会继承B的方法，但A和B可以使用A()或B()来互相转换。</code></p>
<p><a href="http://golangtc.com/t/57fdbb43b09ecc08ce000121" target="_blank" rel="external">golangtc</a></p>
<h2 id="Go-中找出实现了某接口的代码"><a href="#Go-中找出实现了某接口的代码" class="headerlink" title="Go 中找出实现了某接口的代码"></a>Go 中找出实现了某接口的代码</h2><pre><code class="bash">egrep -nr &#39;^func (.*) ReadByte\(&#39; *
</code></pre>
<h2 id="Golang中实现优雅关闭程序"><a href="#Golang中实现优雅关闭程序" class="headerlink" title="Golang中实现优雅关闭程序"></a>Golang中实现优雅关闭程序</h2><pre><code class="bash">func main() {

    sigs := make(chan os.Signal, 1)
    done := make(chan bool, 1)

    // sigs 表示将收到的信号放到这个管道中。后面的参数表示你想处理的系统信号
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

    //开启一个Go routine来监听信号
    go func() {
        sig := &lt;-sigs
        done &lt;- true
    }()

    //这里添加你的程序的功能（监听器，处理器等）
    fmt.Println(&quot;awaiting signal&quot;)
    &lt;-done
    fmt.Println(&quot;exiting&quot;)
}
</code></pre>
<p>常见信号:</p>
<pre><code class="bash">Signal Name    Number    Description
SIGHUP    1    Hangup (POSIX)
SIGINT    2    Terminal interrupt (ANSI)
SIGQUIT    3    Terminal quit (POSIX)
SIGILL    4    Illegal instruction (ANSI)
SIGTRAP    5    Trace trap (POSIX)
SIGIOT    6    IOT Trap (4.2 BSD)
SIGBUS    7    BUS error (4.2 BSD)
SIGFPE    8    Floating point exception (ANSI)
SIGKILL    9    Kill(can&#39;t be caught or ignored) (POSIX)
SIGUSR1    10    User defined signal 1 (POSIX)
SIGSEGV    11    Invalid memory segment access (ANSI)
SIGUSR2    12    User defined signal 2 (POSIX)
SIGPIPE    13    Write on a pipe with no reader, Broken pipe (POSIX)
SIGALRM    14    Alarm clock (POSIX)
SIGTERM    15    Termination (ANSI)
SIGSTKFLT    16    Stack fault
SIGCHLD    17    Child process has stopped or exited, changed (POSIX)
SIGCONT    18    Continue executing, if stopped (POSIX)
SIGSTOP    19    Stop executing(can&#39;t be caught or ignored) (POSIX)
SIGTSTP    20    Terminal stop signal (POSIX)
SIGTTIN    21    Background process trying to read, from TTY (POSIX)
SIGTTOU    22    Background process trying to write, to TTY (POSIX)
SIGURG    23    Urgent condition on socket (4.2 BSD)
SIGXCPU    24    CPU limit exceeded (4.2 BSD)
SIGXFSZ    25    File size limit exceeded (4.2 BSD)
SIGVTALRM    26    Virtual alarm clock (4.2 BSD)
SIGPROF    27    Profiling alarm clock (4.2 BSD)
SIGWINCH    28    Window size change (4.3 BSD, Sun)
SIGIO    29    I/O now possible (4.2 BSD)
SIGPWR    30    Power failure restart (System V)
</code></pre>
<h3 id="检查程序监控了哪些信号"><a href="#检查程序监控了哪些信号" class="headerlink" title="检查程序监控了哪些信号"></a>检查程序监控了哪些信号</h3><p><a href="http://unix.stackexchange.com/questions/85364/how-can-i-check-what-signals-a-process-is-listening-to" target="_blank" rel="external">signals</a></p>
<h2 id="Golang中的struct-tag使用"><a href="#Golang中的struct-tag使用" class="headerlink" title="Golang中的struct tag使用"></a>Golang中的struct tag使用</h2><pre><code class="bash">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

// Person :
type Person struct {
    Name string `mytag:&quot;HelloName&quot;`
}

func main() {
    p := Person{Name: &quot;emacsist&quot;}
    refValue := reflect.ValueOf(&amp;p)

    fields := refValue.Elem()
    for i := 0; i &lt; fields.NumField(); i++ {
        field := fields.Field(i)
        fieldName := fields.Type().Field(i).Name
        fieldValue := field.Interface()
        fieldTag := fields.Type().Field(i).Tag.Get(&quot;mytag&quot;)
        fmt.Printf(&quot;fieldName = %v, fieldValue = %v, tagName = %v\n&quot;, fieldName, fieldValue, fieldTag)
    }
}
</code></pre>
<h2 id="限制Goalng的HTTP-工作线程-goroutine"><a href="#限制Goalng的HTTP-工作线程-goroutine" class="headerlink" title="限制Goalng的HTTP 工作线程(goroutine)"></a>限制Goalng的HTTP 工作线程(goroutine)</h2><pre><code class="bash">    connectionCount := 5000

    l, err := net.Listen(&quot;tcp&quot;, &quot;:9090&quot;)

    if err != nil {
        log.Fatalf(&quot;Listen: %v&quot;, err)
    }

    l = netutil.LimitListener(l, connectionCount)
    log.Fatal(http.Serve(l, nil))
    logrus.Infof(&quot;start server success. %v&quot;, ListenAddress)
</code></pre>
<h2 id="为什么我的内存没有被操作系统回收？"><a href="#为什么我的内存没有被操作系统回收？" class="headerlink" title="为什么我的内存没有被操作系统回收？"></a>为什么我的内存没有被操作系统回收？</h2><p><a href="http://stackoverflow.com/questions/24376817/go-1-3-garbage-collector-not-releasing-server-memory-back-to-system" target="_blank" rel="external">stackoverflow</a></p>
<p><a href="https://golang.org/pkg/runtime/debug/" target="_blank" rel="external">golang</a></p>
<h2 id="Golang1-8-中的优雅关闭-http"><a href="#Golang1-8-中的优雅关闭-http" class="headerlink" title="Golang1.8 中的优雅关闭 http"></a>Golang1.8 中的优雅关闭 http</h2><pre><code class="go">
    s := &amp;http.Server{
        Addr: &quot;:9090&quot;,
    }
    go func() {
        log.Infof(&quot;%s&quot;, s.ListenAndServe())
    }()
    // Handle SIGINT and SIGTERM.
    ch := make(chan os.Signal)
    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
    log.Println(&lt;-ch)

    log.Println(&quot;http server gracefully stopping...&quot;)
    // Stop the service gracefully.
    s.Shutdown(context.Background())
    log.Println(&quot;http server gracefully shutdown done...&quot;)
</code></pre>
<h2 id="按-github-风格的项目组织结构"><a href="#按-github-风格的项目组织结构" class="headerlink" title="按 github 风格的项目组织结构"></a>按 github 风格的项目组织结构</h2><p><a href="https://github.com/golang/go/wiki/GithubCodeLayout" target="_blank" rel="external">github code layout</a></p>
<h2 id="压缩编译后的文件大小"><a href="#压缩编译后的文件大小" class="headerlink" title="压缩编译后的文件大小"></a>压缩编译后的文件大小</h2><h3 id="去掉符号信息"><a href="#去掉符号信息" class="headerlink" title="去掉符号信息"></a>去掉符号信息</h3><pre><code class="bash">go build -ldflags &quot;-s -w&quot;
</code></pre>
<h3 id="使用-upx-压缩"><a href="#使用-upx-压缩" class="headerlink" title="使用 upx 压缩"></a>使用 upx 压缩</h3><pre><code class="bash">upx -9 GoBinaryFile
</code></pre>
<h2 id="Golang-中的-web"><a href="#Golang-中的-web" class="headerlink" title="Golang 中的 web"></a>Golang 中的 web</h2><p>在 web 中使用 panic 只会退出当前的 goroutine ，而不会整个应用程序退出。</p>
<p>在一般应用中，如果没有捕捉 panic() 的话，就会导致整个应用退出:</p>
<pre><code class="bash">package main

import (
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    wg := sync.WaitGroup{}
    wg.Add(1)
    go func() {
        time.Sleep(5 * time.Second)
        println(&quot;Hello World&quot;)
        panic(&quot;==================&gt;&quot;)
    }()

    go func() {
        time.Sleep(2 * time.Second)
        println(&quot;Hello World2&quot;)
        panic(&quot;==================&gt;2&quot;)
    }()
    wg.Wait()
}
</code></pre>
<h2 id="短声明注意"><a href="#短声明注意" class="headerlink" title="短声明注意"></a>短声明注意</h2><p>短声明只能声明局部变量，而且它会覆盖外部的同名变量。</p>
<p>所以，如果目的是想进行外部变量的初始化的话，这点可能没达到我们想要的目的，这点要特别注意。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不论显式还是隐式的 <em>常量</em> 的类型转换，常量从一种类型转换为另一种类型，都要求目标类型能够表示 <em>原值</em></p>
<h2 id="Golang-中格式化日期"><a href="#Golang-中格式化日期" class="headerlink" title="Golang 中格式化日期"></a>Golang 中格式化日期</h2><pre><code class="bash">YYYY-MM-DD HH:mm:ss 
对应
2006-01-02 15:04:05
</code></pre>
<h2 id="Go-中发送登录请求（保持-cookie"><a href="#Go-中发送登录请求（保持-cookie" class="headerlink" title="Go 中发送登录请求（保持 cookie)"></a>Go 中发送登录请求（保持 cookie)</h2><p><a href="https://stackoverflow.com/questions/18414212/golang-how-to-follow-location-with-cookie" target="_blank" rel="external">stackoverflow.com</a></p>
<pre><code class="bash">package main

import (
    &quot;golang.org/x/net/publicsuffix&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;net/http/cookiejar&quot;
)

func main() {
    options := cookiejar.Options{
        PublicSuffixList: publicsuffix.List,
    }
    jar, err := cookiejar.New(&amp;options)
    if err != nil {
        log.Fatal(err)
    }
    client := http.Client{Jar: jar}
    resp, err := client.Get(&quot;http://dubbelboer.com/302cookie.php&quot;)
    if err != nil {
        log.Fatal(err)
    }
    data, err := ioutil.ReadAll(resp.Body)
    resp.Body.Close()
    if err != nil {
        log.Fatal(err)
    }
    log.Println(string(data))
}
</code></pre>
<h2 id="Go-中提交表单"><a href="#Go-中提交表单" class="headerlink" title="Go 中提交表单"></a>Go 中提交表单</h2><pre><code class="bash">
    form := url.Values{}
    form.Add(&quot;qps&quot;, strconv.FormatInt(qps, 10))


    setQPSRequest, err := http.NewRequest(&quot;POST&quot;, loginURL, strings.NewReader(form.Encode()))
    if err != nil {
        return
    }

    setQPSRequest.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=utf-8&quot;)
</code></pre>
<h2 id="logrus-设置日志时间格式"><a href="#logrus-设置日志时间格式" class="headerlink" title="logrus 设置日志时间格式"></a>logrus 设置日志时间格式</h2><p>logrus 设置日期</p>
<pre><code class="bash">func init() {
    formatter := &amp;logrus.TextFormatter{
        FullTimestamp: true,
    }
    logrus.SetFormatter(formatter)
}
</code></pre>

                                
    </div>
</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持 emacsist</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/img/wxpay.jpeg" alt="">
          </li>
        
          <li class="item">
            <img src="/img/alipay.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/books/"
              rel="noopener noreferrer"
              target="_self"
              >
              阅读
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
